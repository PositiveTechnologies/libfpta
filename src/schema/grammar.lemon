/*
 * Copyright 2016-2017 libfptu authors: please see AUTHORS file.
 *
 * This file is part of libfptu, aka "Fast Positive Tuples".
 *
 * libfptu is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * libfptu is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with libfptu.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * libfptu = { Fast Positive Tuples, aka Позитивные Кортежи }
 *
 * The kind of lightweight linearized tuples, which are extremely handy
 * to machining, including cases with shared memory.
 * Please see README.md at https://github.com/leo-yuriev/libfptu
 *
 * The Future will Positive. Всё будет хорошо.
 *
 * "Позитивные Кортежи" дают легковесное линейное представление небольших
 * JSON-подобных структур в экстремально удобной для машины форме,
 * в том числе при размещении в разделяемой памяти.
 */

/******************************************************************************
 *
 * Here is the grammar of "FPTU schema" for "Lemon Parser Generator".
 * Please see https://en.wikipedia.org/wiki/Lemon_Parser_Generator
 *
 ******************************************************************************/

%token_prefix TOKEN_
%token_type {Token}
%name {Lemon}
%extra_argument {IFrontend* __maybe_unused frontend}
%default_destructor {destroy $$;}

%include {
  #include "src/schema/ast.h"
  #include "src/schema/interfaces.h"
  #include "grammar.h"
  #include "fast_positive/tuples_internal.h"

  #include <cassert>
  #include <cstdlib>
  #include <cstdio>

  using namespace fptu::Schema::Compiler;

  /* Управление памятью и время жизни объектов внутри парсера.
   *
   * Штатный шаблон Lemon написан на C, а не на C++. Поэтому достаточно
   * затруднительно обучить его корректно обрабатывать исключения и
   * разрушать сопутствующие объекты.
   *
   * Вполне возможно, что "проблему" решит использование shared_ptr, но
   * при этом возникнет логичная необходимость использовать shared_ptr
   * во всем остальном коде компилятора. В результате существенно возрастут
   * накладные расходы, а главное утратится очевидная прозрачность
   * владения объектами.
   *
   * С другой стороны, компилятор не является резидентным (долгоживущим)
   * сервисом и, следовательно, пока нет необходимости исключить утечку
   * памяти (разрушать все временные объекты) при возникновении исключений
   * в коде C++.
   *
   * Поэтому внутри кода парсера, который используется шаблоном Lemon,
   * реализован следующий подход:
   *   - используются обычные указатели с ручной move-семантикой.
   *   - передача сформированных объектов из парсера в AST происходит
   *     посредством unique_ptr.
   *
   * Таким образом, если в коде шаблона Lemon нет ошибок, то утечки памяти
   * возможны только при генерации исключений в ходе конструировании
   * объектов генерируемых при построении AST-дерева. */

  static inline void destroy(unsigned &value) {
    value = ~0u;
  }

  static inline void destroy(Token &token) {
    token.text = nullptr;
    token.length = 0;
  }

  template<class T> static inline void destroy(T* ptr) {
    if (ptr)
      delete ptr;
  }

  template<class T> static inline void move(T* &target, T* &source) {
    assert(! target);
    destroy(target);
    target = source;
    source = nullptr;
  }

  template<class T> static inline std::unique_ptr<T> get(T* &source) {
    std::unique_ptr<T> result(source);
    source = nullptr;
    return result;
  }

  /* В штатном шаблоне от Lemon есть несколько недочетов. В частности
   * неиспользуемые параметры и сравнение signed с unsigned.
   * Можно конечно поправить шаблон, но эти изменения будет сложно вернуть в
   * mainstream, а поддерживать локально неудобно. Поэтому проще выключить
   * эти конкретные предупреждения компилятора для кода из шаблона. */
  #if defined(__GNUC__)
  #  pragma GCC diagnostic push
  #  pragma GCC diagnostic ignored "-Wunused-parameter"
  #  pragma GCC diagnostic ignored "-Wsign-compare"
  #elif defined(__clang__)
  #  pragma clang diagnostic push
  #  pragma clang diagnostic ignored "-Wunused-parameter"
  #  pragma clang diagnostic ignored "-Wsign-compare"
  #elif defined(_MSC_VER)
  #  pragma warning(push)
  #endif
}

%code {
  /* Восстанавливаем выключенные предупреждения */
  #if defined(__GNUC__)
  #  pragma GCC diagnostic pop
  #elif defined(__clang__)
  #  pragma clang diagnostic pop
  #elif defined(_MSC_VER)
  #  pragma warning(pop)
  #endif

  namespace fptu {
  namespace Schema {
  namespace Compiler {

  class Parser : public IParser {
  protected:
    void *lemon_;
    IFrontend *frontend_;

  public:
    Parser(IFrontend *frontend)
        : lemon_(LemonAlloc(::malloc)), frontend_(frontend) {
      if (options.verbose)
        EnableTrace();
    }

    ~Parser() { LemonFree(lemon_, ::free); }

    void Push(const ILexer::Result &item) {
      Lemon(lemon_, item.id, item, frontend_);
    }

    void EnableTrace(FILE *file = ::stdout, const char *prefix = "[lemon] ") {
  #ifndef NDEBUG
      LemonTrace(file, (char *)prefix);
  #else
      (void)file;
      (void)prefix;
  #endif /* NDEBUG */
    }
  };

  IParser *IParser::Create(IFrontend *frontend) { return new Parser(frontend); }

  } /* namespace Compiler */
  } /* namespace Schema */
  } /* namespace fptu */
}

%stack_overflow {
  frontend->Error("Parser stack overflow");
}

%parse_failure {
  frontend->Error("Parse failure");
}

%syntax_error {
  frontend->SyntaxError(TOKEN);
}

%start_symbol scheme

//------------------------------------------------------------------------------
// Верхний уровень https://en.wikipedia.org/wiki/Abstract_syntax_tree

// Схема состоит из импорта и списка деклараций
scheme ::= version import top_list(LIST) designation EOF. {
  try {
    frontend->Append(get(LIST));
  } catch (const std::exception &trouble) {
    frontend->HandleException(&trouble);
  }
}

// Версия схемы. Может быть в первоначальной форме "version major;"
version ::= VERSION NUMBER SEMICOLON.
// либо в автоматической форме "version major.minor.rev hash;"
version ::= VERSION NUMBER DOT NUMBER DOT NUMBER DIGEST SEMICOLON.

// Импорт может быть пуст, либо быть набором "import filename;"
import ::= .
import ::= import IMPORT name(NAME) SEMICOLON. {
  try {
    frontend->Import(get(NAME));
  } catch (const std::exception &trouble) {
    frontend->HandleException(&trouble);
  }
}

// Верхнеуровневый список деклараций может быть пустым,
// либо состоять из верхнеуровневых определений (enum, type, tuple)
%type top_list {NodeList *}
%type top_declaration {Node *}
top_list(OUT) ::= . { OUT = nullptr; }
top_list(OUT) ::= top_list(LIST) top_declaration(NODE). {
  assert(!OUT);
  try {
    if (NODE) {
      OUT = LIST ? LIST : new NodeList();
      LIST = nullptr;
      OUT->Append(get(NODE));
    }
  } catch (const std::exception &trouble) {
    frontend->HandleException(&trouble);
  }
}

// Вложенный список деклараций, добавляются объявления полей
%type inner_list {NodeList *}
%type inner_declaration {Node *}
inner_list ::= .
inner_list(OUT) ::= inner_list(LIST) inner_declaration(NODE). {
  assert(!OUT);
  try {
    if (NODE) {
      OUT = LIST ? LIST : new NodeList();
      LIST = nullptr;
      OUT->Append(get(NODE));
    }
  } catch (const std::exception &trouble) {
    frontend->HandleException(&trouble);
  }
}

// Карта назначений. Может быть пустой, но должна начинаться с "designation"
designation ::= DESIGNATION.
designation ::= designation designation_item.
designation_item ::= name AS NUMBER COLON WORD SEMICOLON.
designation_item ::= name AS NUMBER COLON name COMMA WORD SEMICOLON.
designation_item ::= PROHIBITED AS NUMBER SEMICOLON.

//------------------------------------------------------------------------------

// Верхнеуровневые декларации
top_declaration ::= enum.
top_declaration ::= type.
top_declaration ::= tuple.

// Вложенные декларации, добавляются объявления полей
inner_declaration ::= top_declaration.
inner_declaration ::= field.

// Декларация перечислений "enum NAME @xyz { a, b... }"
%type enum {Node *}
%type enum_body {NodeList *}
enum ::= opt_deprecated ENUM ident BEGIN enum_body END.
enum_body ::= enum_item.
enum_body ::= enum_body COMMA enum_item.
enum_item ::= opt_deprecated ident.
enum_item ::= opt_deprecated ident EQUAL NUMBER.

// Декларация кортежей "tuple NAME @xyz ..."
%type tuple {Node *}
tuple ::= TUPLE ident struct_definition.
struct_definition ::= BEGIN inner_list END.
struct_definition ::= COLON name BEGIN inner_list END.

// Декларация типов "type NAME @xyz ..."
%type type {Node *}
type ::= opt_deprecated TYPEDEF ident type_definition.
type_definition ::= struct_definition.
type_definition ::= COLON name suffix SEMICOLON.

// Декларация полей "optional NAME @xyz ..."
%type field {Node *}
field ::= opt_deprecated ident field_definition.
field ::= OPTIONAL ident field_definition.
field_definition ::= type_definition.
field_definition ::= COLON name MAP name suffix SEMICOLON.

//------------------------------------------------------------------------------

%type suffix {unsigned}
suffix(S) ::= opt_array(A) opt_multi opt_repeated(R) . {
  S = A | R;
}

%type opt_multi {unsigned}
opt_multi(OPT) ::= . { OPT = 0; }
opt_multi(OPT) ::= OPEN NUMBER CLOSE. { OPT = 0; }
opt_multi(OPT) ::= OPEN NUMBER COMMA NUMBER CLOSE. { OPT = 0; }

%type opt_array {unsigned}
opt_array(OPT) ::= . { OPT = 0; }
opt_array(OPT) ::= ARRAY. { OPT = Node::array; }

%type opt_repeated {unsigned}
opt_repeated(OPT) ::= . { OPT = 0; }
opt_repeated(OPT) ::= REPEATED. { OPT = Node::repeated; }

%type opt_deprecated {unsigned}
opt_deprecated(OPT) ::= . { OPT = 0; }
opt_deprecated(OPT) ::= DEPRECATED. { OPT = Node::deprecated; }

// Имя определяемого типа/поля
%type ident {Ident *}
ident(IDENT) ::= WORD(NAME). {
  try {
    IDENT = new Ident(NAME);
  } catch (const std::exception &trouble) {
    frontend->HandleException(&trouble);
  }
}
// Опционально с тэгом для привязки к внешним справочникам (локализация и т.д.)
ident(IDENT) ::= WORD(NAME) AT WORD(TAG). {
  try {
    IDENT = new Ident(NAME, TAG);
  } catch (const std::exception &trouble) {
    frontend->HandleException(&trouble);
  }
}

// Отсылка к имени типа. Может быть одним словом или FQTN
%type name {BaseName *}
name(R) ::= WORD(W). {
  try {
    R = new BaseName(W);
  } catch (const std::exception &trouble) {
    frontend->HandleException(&trouble);
  }
}
name(R) ::= name(N) DOT WORD(W). {
  move (R, N);
  try {
    R->Append(W);
  } catch (const std::exception &trouble) {
    frontend->HandleException(&trouble);
  }
}
