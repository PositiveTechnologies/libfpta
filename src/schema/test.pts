/* ОБЩИЕ СВЕДЕНИЯ
 *
 * Представленная СХЕМА выполняет несколько задач:
 *  1) В парадигме наследования определяет как иерархию элементарных типов,
 *     так и иерархию структурных объектов (классов).
 *  2) Описывает структуру объектов (классов) в виде атрибутных деревьев,
 *     состоящих из строго типизированных элементов, с набором отношений между
 *     ними (вхождение полей в структуры, принадлежность к базовому классу).
 *  3) Автоматизирует построение плоских проекций для представления древовидных
 *     вложенных структур (экземпляров классов) в виде плоских кортежей,
 *     в том числе для хранения иерархических структур в БД.
 *  4) Автоматизирует минимизацию требуемого количества колонок для хранения
 *     объектов принадлежащих к одной иерархии классов. Физически при
 *     этом производится совмещение однотипных полей/атрибутов, которые
 *     не могут присутствовать одновременно в экземпляре любого класса иерархии,
       так как определены в разных производных классах с общей базой.
 *  5) Предлагает простой, но достаточный и удобный язык описания схемы,
 *     который обеспечивает развитие (эволюцию) схемы данных с контролируемой
 *     совместимостью с предыдущими версиями.
 *  6) Предлагает машинно-эффективный справочник схемы.
 *
 * Если же рассматривать СХЕМУ утрировано, то она содержит информацию
 * необходимую для конвертации кортежей в JSON-документы и обратно. При этом
 * схему можно рассматривать как словарь, в котором перечислены все соответствия
 * между именами JSON-полей и тегами FPTU-полей с указанием их типа.
 * Соответствующий схеме объект не должен содержать неизвестных полей или
 * нарушать допустимый набор отношений, включая количественные ограничения.
 *
 * Следует отметить, что поддержка устойчивых плоских проекций, в том числе
 * представления в виде FPTU-кортежей, подразумевает активное участие
 * компилятора схемы. В свою очередь, компилятор при этом отслеживает изменение
 * схемы и использование машинных идентификаторов/меток. В том числе,
 * для новых типов и полей компилятор автоматически назначает и вносит такие
 * внутренние машинные идентификаторы в исходный текст описания схемы.
 *
 * Таким образом, компилятор отслеживает совместимость представления объектов в
 * виде FPTU-кортежей и других плоских проекций с новой версией схемы.
 * В частности, поэтому СХЕМА обеспечивает эволюционное развитие, с сохранением
 * совместимости без перекомпиляции приложений и без конвертации данных. */

/* ПРЕОБРАЗОВАНИЕ В ПЛОСКУЮ ФОРМУ
 *
 * Под "плоской" формой подразумевается проекция иерархической/древовидной
 * структуры (ограниченной вложенности и сложности) на одномерный набор полей.
 * Такая проекция позволяет хранить исходную структуру, как в плоском одном
 * кортеже без вложенности, так и в записи колоночной или реляционной СУБД.
 *
 * Кроме этого, в сравнении с иерархической/древовидной формой, такое плоское
 * представление, при соблюдении некоторых разумных ограничений, позволяет
 * существенно (нередко многократно) сократить накладные затраты при машинной
 * обработке.
 *
 * Подобное отображение возможно только при введении явных ограничений на
 * глубину вложенности структур и одновременно на количество экземпляров всех
 * вложенных полей, которые являются структурами.
 *
 * Для получения плоской проекции ограниченной древовидной структуры в виде
 * FPTU-кортежа, необходимо и достаточно, каждому возможному полю в каждой
 * вложенной структуре, назначить свой уникальный тэг/номер. Проще говоря,
 * нам необходимо построчно "выписать на листок" максимально полный вариант
 * структуры, рекурсивно обходя все вложенные структуры и поля, а после
 * пронумеровать выписанные строки. Так мы назначим уникальный идентификатор
 * каждому допустимому экземпляру поля в каждом вложенном экземпляре структуры.
 *
 * Не следует считать приведённое выше описание буквальным алгоритмом, с
 * соответствующими ограничениями и недостатками. Например, в частности, для
 * каждой ветви в иерархии классов может быть сформирован список обязательных
 * (не опциональных) полей/атрибутов, которые всегда обязаны присутствовать.
 * Соответственно, при представлении в виде FPTU-кортежа для таких фиксированных
 * полей/атрибутов могут быть сразу назначены смешения, а при создании
 * резервироваться место. Что в результате позволит исключить фазу поиска
 * этих полей при доступе к ним.
 *
 * Компилятор схемы автоматизирует и контролирует этот процесс, совмещая его
 * с назначением внутренних идентификаторов FPTU-полей и построением
 * справочника схемы. */

//-----------------------------------------------------------------------------

/* Номер версии в формате major.minor.revision, затем контрольная сумма.
 * При внесении изменений компилятор сам оценивает совместимость
 * новой версии схемы со старой, и автоматически
 * инкремирует revision или minor. Менять ручками эту запись нельзя,
 * но можно сбросить задав новую major-версию, например "version 2;" */
version 1.0.0 $0123456789ABCDEF;

// Поддерживается include, примерно как в C/C++.
include test_import;

//-----------------------------------------------------------------------------
// Базовые возможности

// Поддерживаются enum-ы.
// Объявляемые таким образом константы и имена попадут как в генерируемый
// h-файл, так и в справочник схемы.
//
// Правила назначения значений такие-же как C/C++.
// Но базовый тип значений всегда uint16_t.
enum enum_1 {
  case_a, case_b, case_c = 34
}

// Пример объявление структуры
type struct_1 {
  x: string;
  optional y: sint64; // поле 'y' опционально, т.е. может отсутствовать (что эквивалентно NIL/NULL).
  ? z: sint64;        // знак вопроса - синоним 'optional'.

  // Можно объявить вложенный тип. Важно, если мы уберём 'type',
  // то сразу определим поле и одноимённый тип, а не только тип.
  type internal_type {
    field: enum_1;
  }

  // Объявляем поле используя только-что определённый тип
  struct_field_via_type : internal_type;

  // Также можно объявить поле-структуру непосредственно,
  // без предварительного объявления типа.
  struct_field_directly {
    field: enum_1;
  }

  // Поле или тип можно пометить как устаревшее.
  // Смысл такой пометки в том, что планируемая runtime поддержка позволит
  // читать и удалять такие поля в кортежах, но не даст добавлять или изменять.
  deprecated old : int;
  ! one_more_legacy : string; // восклицательный знак - синоним 'deprecated'.
}

//-----------------------------------------------------------------------------
// Динамические массивы (переменной длины), Коллекции, Фиксированные массивы (фиксированной длины)

// Динамический массив - это явно создаваемый контейнер с упорядоченным набором
// однотипных элементов, без фиксации их колличества при описании схемы.
//
// Динамический массив входит в родительский контейнер как самостоятельный элемент.
// Иначе говоря, динамический массив должен быть полностью сформирован перед
// добавлением/размещением в родительский контейнер, и полностью заменён (изъят
// и добавлен) при изменении размера.
//
// Объявляем тип, который является динамическим массивом.
type my_array_of_int : int[];

// Коллекция - это безконтейнерный неупорядоченный набор однотипных элементов,
// без фиксации их колличества при описании схемы.
//
// Коллекция всегда размещается в родительском контейнере и формируется просто
// повтором поля, при этом каждый элемент коллекции может быть непосредственно
// изменён или удалён. Однако, в отличие от массивов, порядок элементов
// в коллекции в общем случае не определен.
//
// Признак опциональности для коллекции означает, что в ней может не быть
// ни одного элемента. Соответственно, не-опциональность означает что должен
// быть хотя-бы один элемент.
//
// Объявляем тип-колекцию.
type my_collection_of_int : int...;

// Фиксированный массив - это безконтейнерный упорядоченный набор однотипных
// элементов, c явной фиксацией их количества при описании схемы.
//
// Фиксированный массив можно рассматривать как "синтаксический сахар" или
// макрос для объявления нескольких однотипных полей: field_0, ..., field_N.
// При этом принципиальным является то, что каждому его элементу могут быть
// назначена собственная координата в родительском контейнере. Соответственно,
// каждый элемент фиксированного массива может быть адресован непосредственно.
//
// В текущем понимании, фиксированные массивы не должны поддерживать
// опциональность. Возможно это стоит обсудить.
//
// Объявляем тип, который является фиксированным массивом.
type my_vector_of_int : int<42>;

type my_struct {
  // объявляем два поля-массива,
  // оба определения дают одинаковый результат, разница будет при запросе к справочнику типов
  array1_of_int : int[];           // typeinfo(my_struct.array1_of_int).is_descendant_of(my_array_of_int) == FALSE
  array2_of_int : my_array_of_int; // typeinfo(my_struct.array2_of_int).is_descendant_of(my_array_of_int) == TRUE

  // аналогично с коллекциями
  collection1_of_int : int...;               // typeinfo(my_struct.collection1_of_int).is_descendant_of(my_collection_of_int) == FALSE
  collection2_of_int : my_collection_of_int; // typeinfo(my_struct.collection2_of_int).is_descendant_of(my_collection_of_int) == TRUE

  // так можно объявить коллекцию из массивов (коллекцию из коллекций - нельзя).
  mad1: bool[]...;
  mad2: my_array_of_int...;
}

//-----------------------------------------------------------------------------
// Развертка (линейное отображение) древовидной структуры в кортеж.

/* Цель развертки в получении выгоды за счет "выпрямления пространства",
 * когда к каждому элементу в дереве возможен прямой непосредственный доступ.
 *
 * Суть развертки в назначении уникального идентификатора/номера каждому
 * допустимому элементу древовидной структуры. Что требует фиксации
 * как вложенности, так и максимального количества повторяемых элементов.
 */

type inner {
  a: string;
  b: int;
}

type outer {
  n : bool;
  // Декларируем что нам всегда требуется ДВА элемента 'm'.
  // В результате мы сможем каждому элементу, включая вложенные поля,
  // назначить уникальный идентификатор для непосредственного доступа.
  m : inner<2>;
}

// Объявляем кортеж.
// Для полей кортежа и полей всех вложенных структур, компилятор
// будет назначать уникальные числовые идентификаторы, которые
// позволят непосредственно и независимо адресовать внутри кортежа
// каждое поле.
// Сформированную карту идентификаторов компилятор сформирует ниже,
// в разделе 'designation'.
tuple simple : inner {
  tail : bool;
}

// Для этого кортежа карта назначений будет включать рекурсивную
// развёртку вложенных полей с учётом специфицированных повторений.
tuple event {
  // Декларируем что нам также всегда требуется ДВА элемента 'z'.
  z : outer<2>;
  inside: simple;
}

//-----------------------------------------------------------------------------
// Карта назначений идентификаторов.
// Компилятор сгенерирует её автоматически для всех структур объявленных как 'tuple'.
//
// Пример

designation
  // Для кортежа simple будут просто "пронумерованы"
  // все его возможные поля с указанием типов
  simple.a`1 : inner.a, string;
  simple.b`2 : inner.b, int;
  simple.tail`3 : bool;

  // В event заказано два повтора z:outer, внутри каждого из которых два повтора m:inner;
  // первый повтор z:outer
  event.z0.n`1 : outer.n, bool;
  //// первый повтор m:inner для z_0
  event.z0.m0.a`2 : inner.a, string;
  event.z0.m0.b`3 : inner.b, int;
  //// второй повтор m:inner для z_0
  event.z0.m1.a`4 : inner.a, string;
  event.z0.m1.b`5 : inner.b, int;
  // второй повтор z:outer
  event.z1.n`6 : outer.n, bool;
  //// первый повтор m:inner для z_1
  event.z1.m0.a`7 : inner.a, string;
  event.z1.m0.b`8 : inner.b, int;
  //// второй повтор m:inner для z_1
  event.z1.m1.a`9 : inner.a, string;
  event.z1.m1.b`10 : inner.b, int;

  // Тип `simple` объявлен кортежем, поэтому поле `inside` внутри `event`
  // будет иметь тип "вложеный кортеж".Соответственно, к его элементам
  // нельзя получить непосредственный доступ из event.
  // Но поэтому для доступа к полю `inside` нужен лишь один идентификатор.
  event.inside`11 : simple, inner;

end.

//------------------------------------------------------------------------------

// Если карту назначений изменить вручную, то компилятор заметит махинацию
// и увеличит minor в версии, пометив таким образом что новая схема не совместима со старой.

// Кроме карты назначений компилятор сгенерирует еще несколько продуктов:
// 1) h-файлы с дефайнами (см ниже);
// 2) Некий отделимый машинный справочник-описание схемы,
//    используя который можно общащаться к полям по имени,
//    в том числе (де)сериализовать кортежи в JSON и обратно.
// 3) Набор неких C++ type traits, по котором посредством шаблонов С++ можно
//    сгенерировать "объектную обвязку" вокруг libfptu;

#define PTS_simple_a	1
#define PTS_simple_b	2
#define PTS_simple_tail	3
#define PTS_event_z0_n		1
#define PTS_event_z0_m0_a	2
#define PTS_event_z0_m0_b	3
#define PTS_event_z0_m1_a	4
#define PTS_event_z0_m1_b	5
#define PTS_event_z1_n		6
#define PTS_event_z1_m0_a	7
#define PTS_event_z1_m0_b	8
#define PTS_event_z1_m1_a	9
#define PTS_event_z1_m1_b	10
#define PTS_event_inside	11
