/* ОБЩИЕ СВЕДЕНИЯ
 *
 * Если рассматривать схему упрощенно, то она содержит информацию необходимую
 * для конвертации кортежей в JSON-документы и обратно. В том числе, схему
 * можно рассматривать как словарь, в котором перечислены все соответствия
 * между именами JSON-полей и тегами fptu-полей с указанием их типа.
 * Соответствующий схеме документ не должен содержать неизвестных полей или
 * нарушать допустимый набор отношений, включая количественные ограничения.
 *
 * На самом деле fptu-схема выполняет несколько задач:
 *  1) Описывает иерархию типов, включая структуры. При этом в качестве
 *     корневых типов всегда используются нативные типы fptu.
 *  2) Описывает структуру записей-документов в виде дерева типизированных
 *     элементов/атрибутов с допустимым набором отношений/связей между
 *     ними (вхождение полей в структуры).
 *  3) Предлагает простой, но достаточный и удобный язык описания схемы,
 *     который обеспечивает развитие (эволюцию) схемы данных с контролируемой
 *     совместимостью с предыдущими версиями.
 *  4) Автоматизирует построение проекций для представления древовидных
 *     структур в виде плоских/одномерных кортежей, в том числе для
 *     хранения иерархических структур в колоночных базах данных.
 *  5) Предлагает машинно-эффективный справочник схемы.
 *
 * Следует отметить, что поддержка представления в виде fptu-кортежей и
 * поддержка плоских проекций подразумевает активное участие компилятора схемы,
 * в том числе автоматическое внесение назначенных идентификаторов в исходный
 * текст описания схемы, одновременно с генерацией справочника как машинного
 * представления схемы.
 *
 * Также немаловажно, что функционально схема специфицирует только набор
 * требований, ограничений и координаты полей для двух методов адресации:
 *   1) по именам полей (например в JSON или СУБД)
 *   2) по номерам/тэгам полей (например в fptu-кортежах).
 *
 * Этой информации достаточно для того, чтобы проверить соответствие некоторого
 * объекта/документа/записи схеме и/или получить координаты каждого описанного
 * в схеме элемента. Поэтому:
 *  - С одной стороны, схема достаточно аскетична, НЕ содержит лишней
 *    информации, легка и предельно эффективно в реализации.
 *  - С другой стороны, минимализм функционала вместе с выразительным языком
 *    описания, даёт несколько неожиданных "волшебных" (непривычных) свойств
 *    и позволяет легко манипулировать ими.
 *
 * В частности, схема обеспечивает эволюционное развитие, в том числе
 * с сохранением совместимости без необходимости пересборки приложений.
 */

/* ПРЕОБРАЗОВАНИЕ В ПЛОСКУЮ ФОРМУ
 *
 * Под "плоской" формой подразумевается проекция иерархической/древовидной
 * структуры (ограниченной вложенности и сложности) на одномерный набор полей.
 * Такая проекция позволяет хранить исходную структуру, как в плоском одном
 * кортеже без вложенности, так и в записи колоночной или реляционной СУБД.
 *
 * Кроме этого, в сравнении с иерархической/древовидной формой, такое плоское
 * представление, при соблюдении некоторых разумных ограничений, позволяет
 * существенно (нередко многократно) сократить накладные затраты при машинной
 * обработке.
 *
 * Подобное отображение возможно только при введении явных ограничений на
 * глубину вложенности структур и одновременно на количество экземпляров всех
 * вложенных полей, которые являются структурами.
 *
 * Для получения плоской проекции ограниченной древовидной структуры в виде
 * fptu-кортежа, необходимо и достаточно, каждому возможному полю в каждой
 * вложенной структуре, назначить свой уникальный тэг/номер. Проще говоря,
 * нам необходимо построчно выписать на листок максимально полный вариант
 * структуры, рекурсивно обходя все вложенные структуры и поля, а после
 * пронумеровать выписанные строки. Так мы назначим уникальный идентификатор
 * каждому допустимому экземпляру поля в каждом вложенном экземпляре структуры.
 *
 * Компилятор схемы автоматизирует и контролирует этот процесс, совмещая его
 * с назначением внутренних идентификаторов fptu-полей и построением
 * справочника схемы.
 */

//-----------------------------------------------------------------------------

/* Номер версии в формате major.minor.revision, затем контрольная сумма.
 * При внесении изменений компилятор сам оценивает совместимость
 * новой версии схемы со старой, и автоматически
 * инкремирует revision или minor. Менять ручками эту запись нельзя,
 * но можно сбросить задав новую major-версию, например "version 2;" */
version 1.0.0 $0123456789ABCDEF;

// Поддерживается include, примерно как в C/C++.
include test_import;

//-----------------------------------------------------------------------------
// Базовые возможности

// Поддерживаются enum-ы.
// Объявляемые таким образом константы и имена можно использовать
// двумя способами:
//  - как enum-константы (определения попадут в генерируемый h-файл)
//  - как имена при map-ассоциации (подробности дальше).
//
// Правила назначения значений такие-же как C/C++.
// Но базовый тип значений всегда uint16_t.
enum enum_1 {
  case_a, case_b, case_c = 34
}

// Пример объявление структуры
type struct_1 {
  x: string;
  optional y: sint64; // поле 'y' опционально, т.е. может отсутствовать (что эквивалентно NIL/NULL).
  ? z: sint64;        // знак вопроса - синоним 'optional'.

  // Можно объявить вложенный тип. Важно, если мы уберём 'type',
  // то сразу определим поле и одноимённый тип, а не только тип.
  type internal_type {
    field: enum_1;
  }

  // Объявляем поле используя только-что определённый тип
  struct_field_via_type : internal_type;

  // Также можно объявить поле-структуру непосредственно,
  // без предварительного объявления типа.
  struct_field_directly {
    field: enum_1;
  }

  // Поле или тип можно пометить как устаревшее.
  // Смысл такой пометки в том, что планируемая runtime поддержка позволит
  // читать и удалять такие поля в кортежах, но не даст добавлять или изменять.
  deprecated old : int;
  ! one_more_legacy : string; // восклицательный знак - синоним 'deprecated'.
}

//-----------------------------------------------------------------------------
// Массивы и Коллекции

// Массив - это явно создаваемый контейнер с упорядоченным набором однотипных элементов.
// Массив входит в кортеж как самостоятельный элемент, т.е. должен быть
// полностью сформирован перед добавлением, и полностью заменён при любом изменении.
// Объявляем тип-массив.
type my_array_of_int : int[];

// Коллекция - это неупорядоченный набор однотипных элементов, без создания дополнительного контейнера.
// В кортеже коллекция формируется просто повтором поля, при этом
// каждый экземпляр поля может быть непосредственно изменён или удалён.
// Объявляем тип-колекцию.
type my_collection_of_int : int...;

type my_struct {
  // объявляем два поля-массива,
  // оба определения дают одинаковый результат, разница будет при запросе к справочнику типов
  array1_of_int : int[];           // typeinfo(my_struct.array1_of_int).is_descendant_of(my_array_of_int) == FALSE
  array2_of_int : my_array_of_int; // typeinfo(my_struct.array2_of_int).is_descendant_of(my_array_of_int) == TRUE

  // аналогично с коллекциями
  collection1_of_int : int...;               // typeinfo(my_struct.collection1_of_int).is_descendant_of(my_collection_of_int) == FALSE
  collection2_of_int : my_collection_of_int; // typeinfo(my_struct.collection2_of_int).is_descendant_of(my_collection_of_int) == TRUE

  // так можно объявить коллекцию из массивов (коллекцию из коллекций - нельзя).
  mad1: bool[]...;
  mad2: my_array_of_int...;
}

//-----------------------------------------------------------------------------
// Отображения с использованием enum-ов

type struct_2 {
  // Этот "ребус" означает генерацию отображения, похожего на key-value.
  // Как-бы ключом будет ранее определённый enum (перед стрелкой),
  // а заданный тип (после стрелки) будет использован для значений.
  xyz : enum_1 => int;
  // С учётом внутренностей enum_1 определение выше будет эквивалентно:
  xyz_the_same {
   ? case_a: int;
   ? case_b: int;
   ? case_c: int;
  }

  // Отображения можно комбинировать с любыми валидными определениями.
  mad3 : enum_1 => struct_1[]...;
}

//-----------------------------------------------------------------------------
// Развертка (линейное отображение) древовидной структуры в кортеж.

/* Цель развертки в получении выгоды за счет "выпрямления пространства",
 * когда к каждому элементу в дереве возможен прямой непосредственный доступ.
 *
 * Суть развертки в назначении уникального идентификатора/номера каждому
 * допустимому элементу древовидной структуры. Что требует фиксации
 * как вложенности, так и максимального количества повторяемых элементов.
 */

type inner {
  a: string;
  b: int;
}

type outer {
 n : bool;
 // Декларируем что нам требуется два элемента 'm'.
 // В результате мы получим как-бы массив фиксированного размера,
 // и сможем каждому элементу, включая вложенные поля,
 // назначить уникальный идентификатор для непосредственного доступа.
 m : inner<2>;
}

// Объявляем кортеж.
// Для полей кортежа и полей всех вложенных структур, компилятор
// будет назначать уникальные числовые идентификаторы, которые
// позволят непосредственно и независимо адресовать внутри кортежа
// каждое поле.
// Сформированную карту идентификаторов компилятор сформирует ниже,
// в разделе 'designation'.
tuple simple : inner {
  tail : bool;
}

// Для этого кортежа карта назначений будет включать рекурсивную
// развёртку вложенных полей с учётом специфицированных повторений.
tuple event {
 // Декларируем что нам также требуется два элемента 'z'.
  z : outer<2>;
  inside: simple;
}

//-----------------------------------------------------------------------------
// Карта назначений идентификаторов.
// Компилятор сгенерирует её автоматически для всех структур объявленных как 'tuple'.

designation
  // Для кортежа simple будут просто "пронумерованы"
  // все его возможные поля с указанием типов
  simple.a`1 : inner.a, string;
  simple.b`2 : inner.b, int;
  simple.tail`3 : bool;

  // В event заказано два повтора z:outer, внутри каждого из которых два повтора m:inner;
  // первый повтор z:outer
  event.z0.n`1 : outer.n, bool;
  //// первый повтор m:inner для z_0
  event.z0.m0.a`2 : inner.a, string;
  event.z0.m0.b`3 : inner.b, int;
  //// второй повтор m:inner для z_0
  event.z0.m1.a`4 : inner.a, string;
  event.z0.m1.b`5 : inner.b, int;
  // второй повтор z:outer
  event.z1.n`6 : outer.n, bool;
  //// первый повтор m:inner для z_1
  event.z1.m0.a`7 : inner.a, string;
  event.z1.m0.b`8 : inner.b, int;
  //// второй повтор m:inner для z_1
  event.z1.m1.a`9 : inner.a, string;
  event.z1.m1.b`10 : inner.b, int;

  // Тип `simple` объявлен кортежем, поэтому поле `inside` внутри `event`
  // будет иметь тип "вложеный кортеж".Соответственно, к его элементам
  // нельзя получить непосредственный доступ из event.
  // Но поэтому для доступа к полю `inside` нужен лишь один идентификатор.
  event.inside`11 : simple, inner;

// Если карту назначений изменить вручную, то компилятор заметит махинацию
// и увеличит minor в версии, пометив таким образом что новая схема не совместима со старой.

// Кроме карты назначений компилятор сгенерирует еще несколько продуктов:
// 1) h-файлы с дефайнами (см ниже);
// 2) Некий отделимый машинный справочник-описание схемы,
//    используя который можно общащаться к полям по имени,
//    в том числе (де)сериализовать кортежи в JSON и обратно.
// 3) Набор неких C++ type traits, по котором посредством шаблонов С++ можно
//    сгенерировать "объектную обвязку" вокруг libfptu;

/*
#define PTS_simple_a	1
#define PTS_simple_b	2
#define PTS_simple_tail	3
#define PTS_event_z0_n		1
#define PTS_event_z0_m0_a	2
#define PTS_event_z0_m0_b	3
#define PTS_event_z0_m1_a	4
#define PTS_event_z0_m1_b	5
#define PTS_event_z1_n		6
#define PTS_event_z1_m0_a	7
#define PTS_event_z1_m0_b	8
#define PTS_event_z1_m1_a	9
#define PTS_event_z1_m1_b	10
#define PTS_event_inside	11
*/
