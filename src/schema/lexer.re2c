/*
 * Copyright 2016-2017 libfptu authors: please see AUTHORS file.
 *
 * This file is part of libfptu, aka "Fast Positive Tuples".
 *
 * libfptu is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * libfptu is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with libfptu.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * libfptu = { Fast Positive Tuples, aka Позитивные Кортежи }
 *
 * The kind of lightweight linearized tuples, which are extremely handy
 * to machining, including cases with shared memory.
 * Please see README.md at https://github.com/leo-yuriev/libfptu
 *
 * The Future will Positive. Всё будет хорошо.
 *
 * "Позитивные Кортежи" дают легковесное линейное представление небольших
 * JSON-подобных структур в экстремально удобной для машины форме,
 * в том числе при размещении в разделяемой памяти.
 */

/******************************************************************************
 *
 * Here is the lexer of "FPTU schema" for RE2C.
 * Please see https://en.wikipedia.org/wiki/Re2c
 *
 ******************************************************************************/

#include "src/schema/ast.h"
#include "src/schema/interfaces.h"
#include "grammar.h"
#include "fast_positive/tuples_internal.h"

#ifndef NDEBUG
#include <cstdio>
#include <cstdlib>
static void __maybe_unused YYDEBUG(int state, unsigned char current) {
    fprintf(stderr, "YYDEBUG %d:'%c' ", state, current);
}
#endif /* NDEBUG */

namespace fptu {
namespace Schema {
namespace Compiler {

class Lexer : public ILexer {
private:
  /* Начало исходного текста */
  const Symbol *const begin_;
  /* Конец исходного текста */
  const Symbol *const end_;
  /* Указатель разбора (текущая позиция) */
  const Symbol *head_;
  /* Конец последней выделенной лексемы */
  const Symbol *text_;

  /* Пропускает многострочный комментарий в стиле C. */
  Result comment_ml();
  /* Пропускает однострочный комментарий в стиле C++. */
  Result comment_sl();
  /* Сообщает о неожиданном символе/табуляции
   * и пропускает все до конца строки. */
  void unexpected(bool tab);

  IFrontend *frontend_;
  ISourcer *sourcer_;

protected:
  /* Строит лексему между последней обработанной позицией
   * и текущим указателем разбора. */
  Result token(TokenId id, unsigned skip = 0, unsigned cutoff = 0) const {
    const Symbol *begin = text_ + skip;
    const Symbol *end = head_ - cutoff;

    return Result(id, begin, (unsigned)(end - begin));
  }

public:
  Lexer(IFrontend *frontend, ISourcer *sourcer)
    : begin_(sourcer->begin()), end_(sourcer->end()), head_(begin_), text_(0),
      frontend_(frontend), sourcer_(sourcer)
  {}

  /* Выделяет и возвращает очередную лексему. */
  Result Scan();

  /* Возвращает локацию для текущей позиции разбора. */
  Location WhereNow() const { return sourcer_->Where(text_); }
};

ILexer* ILexer::Create(IFrontend *frontend, ISourcer *source) {
  return new Lexer(frontend, source);
}

ILexer::Result Lexer::Scan() {
  const Symbol * YYMARKER;

  /*!re2c
      re2c:define:YYCTYPE  = "Symbol";
      re2c:define:YYCURSOR = head_;
      re2c:define:YYLIMIT  = end_;
      re2c:yyfill:enable   = 0;
      re2c:indent:top      = 1;

      space = [ \f\r];
      tab = [\t\v];
      eol = "\n";
      digit = [0-9];
      alpha = [A-Za-z\x80-\xFF];
      digest = "$" [0-9a-fA-F]{16};

      version = 'version';
      import = 'include';
      enum = 'enum';
      typedef = 'type' | "~";
      tuple = 'tuple' | "&";
      designation = 'designation';

      begin = "{" | 'begin';
      end = "}" | 'end';

      colon = ":";
      semicolon = ";";
      comma = ",";
      dot = [./];

      array = 'array' | "[]";
      repeated = 'repeated' | "..." | "…";
      optional = 'optional' | "?";
      deprecated = 'deprecated' | "!";
      as = "`" | 'as';
      legacy = 'legacy' | "-";

      open = "<" | "(";
      close = ">" | ")";

      ref = "->" | "→";
      asterix = "*";
      map = "=>" | "⇒";
      at = "@";
      equal = "=";
  */

  /* Пропускаем https://en.wikipedia.org/wiki/Byte_order_mark */
  const uint8_t utf8bom[3] = {0xEF, 0xBB, 0xBF};
  if (end_ - head_ >= 3 && memcmp(head_, utf8bom, sizeof(utf8bom)) == 0)
    head_ += 3;

  while (head_ != end_) {
    /* Переходим к концу последней найденной лексемы. */
    text_ = head_;

    /*!re2c
        "/*"                          { return comment_ml(); }
        "//"                          { return comment_sl(); }
        eol                           { continue; }
        space                         { continue; }

        version                       { return token(TOKEN_VERSION); }
        import                        { return token(TOKEN_IMPORT); }

        enum                          { return token(TOKEN_ENUM); }
        typedef                       { return token(TOKEN_TYPEDEF); }
        tuple                         { return token(TOKEN_TUPLE); }
        designation                   { return token(TOKEN_DESIGNATION); }

        dot                           { return token(TOKEN_DOT); }
        as                            { return token(TOKEN_AS); }
        at                            { return token(TOKEN_AT); }
        map                           { return token(TOKEN_MAP); }
        equal                         { return token(TOKEN_EQUAL); }
        begin                         { return token(TOKEN_BEGIN); }
        end                           { return token(TOKEN_END); }
        comma                         { return token(TOKEN_COMMA); }
        semicolon                     { return token(TOKEN_SEMICOLON); }
        colon                         { return token(TOKEN_COLON); }
        array                         { return token(TOKEN_ARRAY); }
        repeated                      { return token(TOKEN_REPEATED); }
        optional                      { return token(TOKEN_OPTIONAL); }
        deprecated                    { return token(TOKEN_DEPRECATED); }
        open                          { return token(TOKEN_OPEN); }
        close                         { return token(TOKEN_CLOSE); }
        digest                        { return token(TOKEN_DIGEST); }

        digit{1,9}                    { return token(TOKEN_NUMBER); }
        alpha ("_" | alpha | digit)*  { return token(TOKEN_WORD); }
        "\"" [^"\n\t]+ "\""           { return token(TOKEN_WORD, 1, 1); }
        "'" [^'\n\t]+ "'"             { return token(TOKEN_WORD, 1, 1); }
        "«" [^«»\n\t]+ "»"            { return token(TOKEN_WORD, 1, 1); }
        "[„“]" [^„“\n\t]+ "[„“]"      { return token(TOKEN_WORD, 1, 1); }

        tab                           { unexpected(true); continue; }
        *                             { unexpected(false); continue; }
    */
  }
  return token(TOKEN_EOF);
}

void Lexer::unexpected(bool tab) {
  text_ = head_ - 1;
  const Location location = WhereNow();
  frontend_->Error("%s, file '%s', line %u, position %u",
                   tab ? "Tab symbol is not allowed" : "Unexpected symbol",
                   location.filename, location.line, location.position);

  /* Пропускаем символы до конца строки */
  while (head_ != end_) {
    /*!re2c
        eol                           { --head_; break; }
        *                             { continue; }
     */
  }
}

ILexer::Result Lexer::comment_ml() {
  while (head_ != end_) {
    /*!re2c
        "*/"                          { return token(TOKEN_COMMENT); }
        *                             { continue; }
    */
  }
  return token(TOKEN_EOF);
}

ILexer::Result Lexer::comment_sl() {
  while(head_ != end_) {
    /*!re2c
        eol                           { return token(TOKEN_COMMENT); }
        *                             { continue; }
    */
  }
  return token(TOKEN_EOF);
}

} /* namespace Compiler */
} /* namespace Schema */
} /* namespace fptu */
