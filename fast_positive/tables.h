/*
 * Copyright 2016 libfpta authors: please see AUTHORS file.
 *
 * This file is part of libfpta, aka "Fast Positive Tables".
 *
 * libfpta is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * libfpta is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with libfpta.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * libfpta = { Fast Positive Tables, aka Позитивные Таблицы }
 * Please see README.md
 */

#pragma once
#ifndef FAST_POSITIVE_TABLES_H
#define FAST_POSITIVE_TABLES_H

#include "fast_positive/defs.h"
#include "fast_positive/tuples.h"

#include <sys/uio.h> // for struct iovec

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
/* Общие перечисления и структуры */

typedef struct iovec fpta_io;

enum fpta_bits {
    fpta_tables_max = 1000,
    fpta_name_len_min = 1,
    fpta_name_len_max = 42,
    fpta_max_cols = fptu_max_cols,

    fpta_schema_id_bits = 64,

    fpta_column_typeid_bits = fptu_typeid_bits,
    fpta_column_typeid_shift = 0,
    fpta_column_typeid_mask = (1 << fptu_typeid_bits) - 1,

    fpta_column_index_bits = 4,
    fpta_column_index_shift = fpta_column_typeid_bits,
    fpta_column_index_mask = ((1 << fpta_column_index_bits) - 1)
                             << fpta_column_index_shift,

    fpta_column_flag_bits = 4,
    fpta_name_hash_bits = fpta_schema_id_bits - fpta_column_typeid_bits -
                          fpta_column_index_bits,
    fpta_name_hash_shift = fpta_column_index_shift + fpta_column_index_bits
};

/* Экземпляр базы.
 *
 * Базу следует открыть посредством fpta_db_open(), а по завершении всех
 * манипуляций закрыть через fpta_db_close().
 * Открытие и закрытие базы относительно дорогие операции. */
typedef struct fpta_db fpta_db;

/* Транзакция в базе.
 *
 * Чтение и изменение данных всегда происходят в контексте транзакции.
 * Транзакции инициируются посредством fpta_transaction_begin()
 * и завершается через fpta_transaction_end(). */
typedef struct fpta_txn fpta_txn;

/* Курсор для чтения и изменения данных.
 *
 * Курсор связан с диапазоном записей, которые выбираются по
 * задаваемому индексу и опционально фильтруются (если задан фильтр).
 * Курсор позволяет "ходить" по записям, обновлять их и удалять.
 * Открывается курсов посредством fpta_cursor_open(), а закрывается
 * соответственно через fpta_cursor_close(). */
typedef struct fpta_cursor fpta_cursor;

/* Типы данных для ключей (проиндексированных полей) и значений
 * для сравнения в условиях фильтров больше/меньше/равно/не-равно. */
typedef enum fpta_value_type {
    fpta_null,       /* "Пусто", в том числе для проверки присутствия
                      * или отсутствия колонки/поля в строке. */
    fpta_signed_int, /* Integer со знаком, задается в int64_t */
    fpta_unsigned_int, /* Беззнаковый integer, задается в uint64_t */
    fpta_float_point, /* Плавающая точка, задается в double */
    fpta_string, /* Строка, задается в const char* */
    fpta_binary, /* Бинарные данные, задается в fpta_io */

    fpta_begin, /* Псевдо-тип, всегда меньше любого значения.
                 * Используется при открытии курсора для выборки
                 * первой записи посредством range_from. */
    fpta_end,   /* Псевдо-тип, всегда больше любого значения.
                 * Используется при открытии курсора для выборки
                 * последней записи посредством range_to. */
} fpta_value_type;

/* Структура для представления значений.
 *
 * В том числе для передачи ключей (проиндексированных полей)
 * и значений для сравнения в условия больше/меньше/равно/не-равно. */
typedef struct fpta_value {
    fpta_value_type type;
    union {
        int64_t sint;
        uint64_t uint;
        double fp;
        const char *cstr;
        struct {
            void *data;
            unsigned length;
        } binary;
    };
} fpta_value;

enum fpta_error {
    FPTA_SUCCESS = 0,
};

/* Возвращает краткое описание ошибки по её коду.
 *
 * Функция идентифицирует "свои" ошибки и при необходимости по-цепочке
 * вызывает mdbx_strerror() и системную strerror().
 *
 * Функция потоко-НЕ-безопасна в случае системной ошибки, так как при
 * этом вызывается потоко-НЕ-безопасная системная strerror(). */
const char *fpta_strerror(int error);

/* Потоко-безопасный вариант fpta_strerror().
 *
 * Функция потоко-безопасна в том числе в случае системной ошибки, так
 * как при этом вызывается потоко--безопасная системная strerror_r(). */
int fpta_strerror_r(int errnum, char *buf, size_t buflen);

//----------------------------------------------------------------------------
/* Открытие и закрытие БД */

/* Режим сохранности для изменений и БД в целом.
 *
 * Одновременно выбирает компромисс между производительностью по записи
 * и durability. */
typedef enum fpta_durability {

    fpta_readonly, /* Только чтение, изменения запрещены. */

    fpta_sync, /* Полностью синхронная запись на диск.
                * Самый надежный и самый медленный режим.
                *
                * По завершению транзакции выполняется fdatasync().
                * Производительность по записи определяется
                * скоростью диска (порядка 500 TPS для SSD). */

    fpta_lazy, /* "Ленивый" режим записи посредством файловой
                * системы. Детали поведения и сохранность данных
                * полностью определяются видом файловой системой
                * и её настройками. Производительность по записи
                * в основном определяется скоростью диска (порядка
                * 50K TPS для SSD).
                *
                * Изменения будут записываться через файловый
                * дескриптор в обычном режиме, без O_SYNC, O_DSYNC
                * и/или O_DIRECT.
                * В случае аварии могут быть потеряны последние
                * транзакции, при это целостность БД определяется
                * соблюдением data ordered со стороны ФС.
                *
                * Другими словами, кроме потери последних изменений
                * БД может быть разрушена, если ФС переупорядочивает
                * порядок операций записи (см режим data=writeback
                * для ext4). */

    fpta_async /* Самый быстрый режим. Образ БД отображается в
                * память в режиме read-write и изменения
                * производятся только в памяти.
                *
                * Ядро ОС, по своему усмотрению, асинхронно
                * записывает измененные страницы на диск.
                * При этом ядро ОС обещает запись всех изменений
                * при сбое приложения, OOM или при штатной
                * остановке. Но НЕ при сбое в ядре или при
                * отключении питания.
                *
                * Также, БД может быть повреждена в результате
                * некорректных действий приложения (роспись памяти).
                *
                * Производительность по записи в основном
                * определяется скоростью CPU и RAM (более 100K TPS). */
} fpta_durability;

/* Открывает базу по заданному пути и в durability режиме.
 *
 * Аргумент file_mode задает права доступа, которые используются
 * в случае создания новой БД.
 *
 * Аргумент megabytes задает размер БД в мегабайтах. При создании новой
 * БД за основным файлом БД резервируется указанное место. При открытии
 * существующей БД, в зависимости от заданного размера, может быть
 * приведено как увеличения файла, так и его усечение. Причем усечение
 * выполняется не более чем до последней использованной страницы.
 *
 * Аргумент alterable_schema определяет намерения по созданию и/или
 * удалению таблиц в процессе работы. Обещание "не менять схему"
 * позволяет отказаться от захвата pthread_rwlock_t в процессе работы.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_db_open(const char *path, fpta_durability durability,
                 mode_t file_mode, size_t megabytes, bool alterable_schema,
                 fpta_db **db);

/* Закрывает ранее открытую базу.
 *
 * На момент закрытия базы должны быть закрыты все ранее открытые
 * курсоры и завершены все транзакции.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_db_close(fpta_db **db);

//----------------------------------------------------------------------------
/* Инициация и завершение транзакций. */

/* Уровень доступа к данным из транзации. */
typedef enum fpta_level {
    fpta_read = 1, /* Только чтение.
                    * Одновременно бесконфликтно могут выполняться
                    * несколько транзакций в режиме чтения. При
                    * этом они не блокируются пишущими транзакциями,
                    * как из этого же процесса, так и из других
                    * процессов работающих с БД.
                    *
                    * Однако, транзакция уровня изменения схемы
                    * всегда блокирует читающие транзакции в рамках
                    * того же процесса (но не в других процессах).
                    *
                    * При старте каждая читающая транзакция получает
                    * в свое распоряжение консистентный MVCC снимок
                    * всей БД, который видит до своего завершения.
                    * Другими словами, читаюшая транзакция не видит
                    * изменений в данных, которые произошли после
                    * её старта.
                    *
                    * По этой же причине следует избегать долгих
                    * читающих транзакций. Так как такая долгая
                    * транзакция производит удержание снимка-версии
                    * БД в линейной истории и этим приостанавливает
                    * переработку старых снимков (сборку мусора).
                    * Соответственно, долгая читающая транзакция
                    * на фоне большого темпа изменений может
                    * приводить к исчерпанию свободного места в БД. */

    fpta_write = 2, /* Чтение и изменение данных, но не схемы.
                     *
                     * Одновременно в одной БД может быть активна только
                     * одна транзакция изменяющая данные. Проще говоря,
                     * при старте такой транзакции захватывается
                     * глобальный мьютех в разделяемой памяти.
                     *
                     * Пишущая транзакция никак не мешает выполнению
                     * читающих транзакций как в этом, так и в других
                     * процессах.
                     *
                     * Изменения сделанные из пишущей транзакции сразу
                     * видны в её контексте. Но для других транзакций и
                     * процессов они вступят в силу и будут видимы
                     * только после успешной фиксации транзакции.
                     *
                     * Пишущая транзакция может быть либо зафиксирована,
                     * либо отменена (при этом теряются все произведенные
                     * изменения). */

    fpta_schema = 3 /* Чтение, плюс изменение данных и схемы.
                     *
                     * Прежде всего, это пишущая транзакция, т.е.
                     * в пределах БД может быть активна только одна.
                     * Аналогично, транзакция изменения схемы может быть
                     * либо зафиксирована, либо отменена (с потерей всех
                     * изменений).
                     *
                     * Однако, транзакция изменения схемы также
                     * блокирует все читающие транзакции в рамках
                     * своего процесса посредством pthread_rwlock_t.
                     * Такая блокировка обусловлена двумя причинами:
                     *  - спецификой движков libmdbx/LMDB (удаление
                     *    таблицы приводит к закрытию её разделяемого
                     *    дескриптора, т.е. к нарушению MVCC);
                     *  - ради упрощения реализации "Позитивных Таблиц";
                     *
                     * Инициация транзакции изменяющей схему возможна,
                     * только если при БД была открыта в соответствующем
                     * режиме (было задано alterable_schema = true).
                     *
                     * С другой стороны, обещание не менять схему
                     * (указание alterable_schema = false) позволяет
                     * экономить на захвате pthread_rwlock_t при старте
                     * читающих транзакций. */
} fpta_level;

/* Инициация транзакции заданного уровня.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_transaction_begin(fpta_db *db, fpta_level level, fpta_txn **txn);

/* Завершение транзакции.
 *
 * Аргумент abort для пишущих транзакций (уровней fpta_write и fpta_schema)
 * определяет будет ли транзакция зафиксирована или отменена.
 *
 * На момент завершения транзакции должны быть закрыты все связанные
 * с ней курсоры.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_transaction_end(fpta_txn *txn, bool abort);

/* Получение версии данных и схемы.
 *
 * Для снимка данных (которая читается транзакцией)
 * и версию схемы (которая действует внутри транзакции).
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_transaction_versions(fpta_txn *txn, size_t *data, size_t *schema);

//----------------------------------------------------------------------------

/* Управление схемой:
 *  - Изменение схемы происходит в рамках "пишущей" транзакции
 *    уровня fpta_schema.
 *  - Можем создавать таблицы, указывая имя и "набор колонок".
 *  - Можем удалять таблицы по имени.
 *  - Изменения вступают в силу и видны другим процессам только
 *    после фиксации транзакции.
 *
 *  - "Набор колонок" задается в виде массива, каждый элемент которого
 *    создается отдельной вспомогательной функцией.
 *  - При описании колонки указывается её имя, тип данных и признак
 *    индексируемости (primary, secondary, none).
 *  - Для каждой таблицы ровно одна колонка должна быть помечена
 *    как primary.
 *
 * Хэш-коллизии в именах:
 *  - Имена таблиц и колонок подвергаются компактификации (сжатию).
 *  - Можно сказать, что из исходного имени формируется 55-битное
 *    хэш-значение. Соответственно, с вероятностью примерно
 *    1 к 190 миллионам возможна хэш-коллизия.
 *  - При возникновении такой коллизии, при создании таблицы будет
 *    возвращаться ошибка. Как если бы такая таблица уже существовала,
 *    или среди её колонок есть дубликат.
 */

/* Режим индексирования для колонки таблицы. */
enum fpta_index_type {
    fpta_index_none =
        /* Колонка НЕ индексируется. Комбинирование с другими флажками не
           допустимо. */
    0 << fpta_column_index_shift,

    fpta_primary =
        /* Колонка будет использована как первичный ключ таблицы. При создании
        таблицы такая колонка должна быть задана одна, и только одна. Допустимо
        комбинирование с fpta_index_msb, fpta_index_lsb и fpta_index_uniq. */
    1 << fpta_column_index_shift,

    fpta_secondary =
        /* Для колонки будет поддерживаться вторичный
        индекс, т.е. будет создана дополнительная
        служебная таблица с key-value проекцией на
        основной ключ. Поэтому каждый вторичный
        индекс линейно увеличивает стоимость
        операций обновления данных.
        Допустимо комбинирование с fpta_index_msb,
        fpta_index_lsb и fpta_index_uniq. */
    2 << fpta_column_index_shift,

    /* Флажки для выбора режим сравнения при построении индексов
    для не-числовых типов: fptu_96..fptu_256 и fptu_string, fptu_nested
    и всех массивов: */

    fpta_index_msb =
        /* в прямом порядке байт, как memcmp() */
    0 << fpta_column_index_shift,

    fpta_index_lsb =
        /* в обратном, начиная с последнего байта. */
    4 << fpta_column_index_shift,

    fpta_index_uniq =
        /* Флажок для требования уникальности ключей, т.е. запрета на
           дубликаты. */
    8 << fpta_column_index_shift,
};

/* Набор колонок для создания таблицы */
typedef struct fpta_column_set {
    // Счетчик заполненных описателей.
    unsigned count;
    // Упакованное внутреннее описание колонок.
    uint64_t internal[fpta_max_cols];
} fpta_column_set;

/* Вспомогательная функция, проверяет корректность имени */
bool fpta_name_validate(const char *name);

/* Вспомогательная функция для создания описания колонок.
 *
 * Добавляет описание колонки в column_set.
 * Аргумент column_name задает имя колонки. Для совместимости в именах
 * таблиц и колонок допускаются символы: 0-9 A-Z a-z _
 * Начинаться имя должно с буквы.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_column_describe(const char *column_name, enum fptu_type data_type,
                         int index_type, fpta_column_set *column_set);

/* Инициализирует column_set перед заполнением посредством
 * fpta_column_describe(). */
void fpta_column_set_init(fpta_column_set *column_set);

/* Cоздание таблицы.
 *
 * Аргумент table_name задает имя таблицы. Для совместимости в именах
 * таблиц и колонок допускаются символы: 0-9 A-Z a-z _
 * Начинаться имя должно с буквы.
 *
 * Аргумент column_set должен быть предварительно заполнен
 * посредством fpta_column_describe(). После создания таблицы column_set
 * не требуется и может быть разрушен.
 *
 * Требуется транзакция уровня fpta_schema. Изменения становятся
 * видимыми из других транзакций и процессов только после успешной
 * фиксации транзакции.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_table_create(fpta_txn *txn, const char *table_name,
                      fpta_column_set *column_set);

/* Удаление таблицы.
 *
 * Требуется транзакция уровня fpta_schema. Изменения становятся
 * видимыми из других транзакций и процессов только после успешной
 * фиксации транзакции.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_table_drop(fpta_txn *txn, const char *table_name);

//----------------------------------------------------------------------------

/* Отслеживание версий схемы,
 * Идентификаторы таблиц/колонок и их кэширование:
 *
 *  - Следует учитывать что схема и все данные могут быть полностью
 *    изменены сторонним процессом. Такое изменение всегда происходит
 *    в контексте "пишущей" транзакции, т.е. изолированно от уже
 *    выполняющихся транзакций чтения.
 *    Другими словами, следует считать, что вне контекста транзакции,
 *    схема и данные волатильны и обновляются асинхронно.
 *
 *  - Таким образом, по-хорошему, трансляция имен таблиц и колонок в
 *    их идентификаторы и фактические типы данных, должна выполняться
 *    в контексте транзакции, т.е. после её инициации.
 *    Однако, изменение схемы происходит редко и не рационально
 *    выполнять такую трансляцию при каждом запросе.
 *    Более того, такая трансляция не может быть эффективно реализована
 *    для всех сценариев получения и обновления данных без введения
 *    некого языка запросов и его интерпретатора.
 *
 *  - Поэтому часть задач по отслеживанию версий схемы и трансляции
 *    имен в идентификаторы переложена на пользователя, см далее.
 *
 *  - При выполнении запросов идентификация таблиц и колонок
 *    производится посредством полей структуры fpta_schema_id.
 *
 *    В свою очередь, каждый экземпляр fpta_schema_id:
 *     1) инициализируется посредством fpta_schema_init(),
 *        которая на вход получает имя таблицы или колонки.
 *     2) перед использованием обновляется в fpta_schema_refresh(),
 *        которая выполняется в контексте конкретной транзакции.
 *
 *  - Функция fpta_schema_refresh(), при обновлении fpta_schema_id,
 *    сравнивает версию схемы в текущей транзакции со значением
 *    внутри fpta_schema_id, и при их совпадении не производит
 *    каких-либо действий.
 *
 *  - Таким образом, пользователю предоставляются средства для
 *    эффективного кэширования зависящей от схемы информации,
 *    а также её обновления по необходимости.
 */

/* Операционный идентификатор таблицы или колонки. */
typedef struct fpta_schema_id {
    size_t version; // Версия схемы для кэширования.
    uint64_t internal; // Упакованное имя, внутренние данные.
    union {
        // для таблицы
        struct {
            unsigned dbi;
            unsigned pk;
        } table;

        // для колонки
        struct {
            int order;           // Номер поля в кортеже.
            enum fptu_type type; // Тип поля в кортеже.
        } column;
    };
    void *handle; // Внутренний дескриптор
} fpta_schema_id;

/* Получение и актуализация идентификаторов таблицы и колонки.
 *
 * Функция работает в семантике кэширования с отслеживанием версии
 * схемы.
 *
 * Перед первым обращением table_id и column_id должны
 * быть инициализирован посредством fpta_schema_init().
 *
 * Аргумент column_id может быть нулевым. В этом случае он
 * игнорируется, и обратывается только table_id.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_schema_refresh(fpta_txn *txn, fpta_schema_id *table_id,
                        fpta_schema_id *column_id);

enum fpta_schema_item { fpta_table, fpta_column };

/* Инициализирует операционный идентификатор.
 *
 * Подготавливает идентификатор к последующему использованию.
 * Агрумент schema_item определяет тип объекта, который будет
 * идентифицироваться.
 *
 * Следует считать, что стоимость операции сопоставима с вычислением
 * MD5 для переданного имени.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_schema_init(fpta_schema_id *id, const char *name,
                     enum fpta_schema_item schema_item);

void fpta_schema_destroy(fpta_schema_id *id);

//----------------------------------------------------------------------------
/* Управление фильтрами. */

/* Варианты условий (типы узлов) фильтра: НЕ, ИЛИ, И, функция-предикат,
 * меньше, больше, равно, не равно... */
typedef enum fpta_filter_bits {
    fpta_node_not = -3,
    fpta_node_or = -2,
    fpta_node_and = -1,
    fpta_node_fn = 0,
    fpta_node_lt = fptu_lt,
    fpta_node_gt = fptu_gt,
    fpta_node_le = fptu_le,
    fpta_node_ge = fptu_ge,
    fpta_node_eq = fptu_eq,
    fpta_node_ne = fptu_ne,
} fpta_filter_bits;

/* Фильтр, формируется пользователем как дерево из узлов-условий.
 *
 * Фильтр может быть пустым, состоять из одного узла или целого дерева
 * начиная с коревого узла типа И или ИЛИ.
 *
 * Текущую реализацию можно считать базовым вариантом для быстрого старта,
 * который в последствии может быть доработан. */
typedef struct fpta_filter {
    fpta_filter_bits type;

    union {
        /* вложенный узел фильтра для "НЕ". */
        struct fpta_filter *node_not;

        /* вложенная пара узлов фильтра для условий "И" и "ИЛИ". */
        struct {
            struct fpta_filter *a;
            struct fpta_filter *b;
        } node_or, node_and;

        /* параметры для вызова функтора/предиката. */
        struct {
            /* идентификатор колонки */
            const fpta_schema_id *column_id;
            /* функция-предикат, получает указатель на найденное поле,
             * или nullptr если такового нет. А также опциональные
             * параметры context и arg.
             * Функция должна вернуть true, если значение колонки/поля
             * удовлетворяет критерию фильтрации.
             */
            bool (*predicate)(const fptu_field *field,
                              const fpta_schema_id *column_id, void *context,
                              void *arg);
            /* дополнительные аргументы для функции-предиката */
            void *context;
            void *arg;
        } node_fn;

        /* параметры для условия больше/меньше/равно/не-равно. */
        struct {
            /* идентификатор колонки */
            const fpta_schema_id *left_id;

            /* значение для сравнения */
            fpta_value right_value;
        } node_cmp;
    };

} fpta_filter;

/* Проверка соответствия кортежа условию фильтра.
 *
 * Предполагается внутреннее использование, но функция также
 * доступна извне. */
bool fpta_filter_match(fpta_filter *fn, fptu_ro tuple);

//----------------------------------------------------------------------------
/* Управление курсорами. */

/* Создает и открывает курсор для доступа к строкам таблицы,
 * включая их модификацию и удаление. Открытый курсор должен быть
 * закрыт до завершения транзакции посредством fpta_cursor_close().
 *
 * Аргументы table_id и column_id перед первым использованием должны
 * быть инициализированы посредством fpta_schema_init(). Предварительный
 * вызов fpta_schema_refresh() не обязателен.
 *
 * Аргументы range_from и range_to задают диапазон выборки по значению
 * ключевой колонки. При необходимости могут быть заданы значения
 * с псевдо-типами fpta_begin и fpta_end.
 *
 * Для успешного открытия курсора соответствующая таблица должна быть
 * предварительно создана, а указанная колонка должна иметь индекс.
 *
 * Успешное открытие курсора не означает наличие данных,
 * удовлетворяющих критерию выборки. Для такой проверки можно
 * использовать функции fpta_cursor_eof(), fpta_cursor_count() и
 * fpta_cursor_get().
 *
 * Фильтр, использованный при открытии курсора, должен существовать и
 * не изменяться до закрытия курсора и всех его клонов/копий.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_open(fpta_txn *txn, const fpta_schema_id *table_id,
                     const fpta_schema_id *column_id, fpta_value range_from,
                     fpta_value range_to, fpta_filter *filter,
                     fpta_cursor **cursor);
int fpta_cursor_close(fpta_cursor *cursor);

/* Проверяет наличие за курсором данных.
 *
 * Отсутствие данных означает что нет возможности их прочитать, изменить
 * или удалить, но не исключает возможности вставки и/или добавления
 * новых данных.
 *
 * При наличии данных возвращает 0, при отсутствии EOF, иначе код ошибки.
 */
int fpta_cursor_eof(fpta_cursor *cursor);

/* Делает копию курсора, т.е. клонирует его.
 *
 * Получение копии курсора можно рассматривать как способ сохранить
 * и повторно использовать его текущую позицию. Копия курсора должна
 * быть закрыта то завершения транзакции.
 * Использованный при открытии курсора фильтр должен существовать и
 * не изменяться до закрытия как исходного курсора, так и всех его
 * клонов/копий.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_clone(fpta_cursor *cursor, fpta_cursor *clone);

/* Перематывает курсор.
 *
 * В действительности переоткрывает его с учетом ранее заданных
 * параметров, но без ряда лишних действий.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_rewind(fpta_cursor *cursor);

/* Считает и возвращает количество строк за курсором.
 *
 * Операция затратна, стоимость порядка O(log N). Производится
 * итеративный подсчет строк посредством временной копии курсора.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_count(fpta_cursor *cursor, size_t *count);

/* Считает и возвращает количество дубликатов для ключа в текущей
 * позиции курсора, БЕЗ учета фильтра заданного при открытии курсора.
 *
 * За курсором должна быть текущая запись. Под дубликатами понимаются
 * запись с одинаковым значением ключевой колонки, что допустимо если
 * соответствующий индекс был БЕЗ флага fpta_index_uniq.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_dups(fpta_cursor *cursor, size_t *dups);

/* Получает строку таблицы, на которой стоит курсор.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_get(fpta_cursor *cursor, fpta_value *key, fptu_ro *tuple);

/* Варианты перемещения курсора. */
typedef enum fpta_seek_operations {
    /* Перемещение по значению ключа в диапазоне заданном
     * при открытии курсора. */
    fpta_range_first,
    fpta_range_last,
    fpta_range_next,
    fpta_range_prev,

    /* Перемещение по дубликатам значения ключа, в случае если
     * соответствующий индекс был БЕЗ флага fpta_index_uniq */
    fpta_dup_first,
    fpta_dup_last,
    fpta_dup_next,
    fpta_dup_prev,

    /* Перемещение по значению ключа без учета диапазона заданного
     * при открытии курсора. */

    /* Перемещение к значению заданному аргументом key */
    fpta_exact_key,

    /* Перемещение к ближайшей позиции, ключ в которой больше или равен
     * значению заданному аргументом key */
    fpta_nearest_key,

    /* TODO: Нет понимания насколько нужны эти режимы, пока оставил. */
    fpta_key_first,
    fpta_key_last,
    fpta_key_next,
    fpta_key_prev,
} fpta_seek_operations;

/* Перемещение курсора.
 *
 * Курсор перемещается к соответствующей строке в пределах диапазона и
 * с учетом фильтра, заданных при открытии курсора.
 *
 * При успешном перемещении и ненулевых значениях аргументов key и tuple,
 * в них будут сохранены значения проиндексированной колонки и строки
 * таблицы в форме кортежа.
 * При нулевых значениях аргументов key и tuple, после успешного
 * перемещения данные могут получены посредством fpta_cursor_get().
 *
 * Для режимов fpta_exact_key и fpta_nearest_key ключ должен быть задан.
 * Более того, эти режимы игнорируют диапазон изначально заданный
 * при открытии курсора аргументами range_from и range_to.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_seek(fpta_cursor *cursor, fpta_seek_operations op,
                     fpta_value *key, fptu_ro *tuple);

//----------------------------------------------------------------------------
/* Манипуляция данными. */

/* Опции при помещении или обновлении данных, т.е. для fpta_cursor_put(). */
typedef enum fpta_put_options {
    /* Вставить новую запись, т.е. не обновлять существующую.
     * Будет возвращена ошибка, если указанный ключ уже присутствует в
     * таблице и соответствующий индекс был с флагом fpta_index_uniq. */
    fpta_insert,
    fpta_nooverwrite = fpta_insert,

    /* Не добавлять новую запись, а обновить текущую запись.
     * За курсором должна быть текущая запись, а ключ передаваемый
     * в аргументе key должен совпадать со значением
     * в текущей позиции курсора. Иначе будет возвращена ошибка. */
    fpta_update,
    fpta_overwrite = fpta_update,

    /* Обновить существующую запись, либо вставить новую. Опция допустима
     * только если соответствующий индекс был с флагом fpta_index_uniq.
     * Иначе будет возвращена ошибка. */
    fpta_upsert
} fpta_put_options;

/* Помещает данные в таблицу.
 *
 * Для заданного ключа будет выполнена вставка или обновление значения,
 * в зависимости от режима заданного аргументом op. Для деталей
 * см описание fpta_put_options.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_put(fpta_cursor *cursor, fpta_put_options op, fpta_value key,
                    fptu_ro value);

/* Удаляет из таблицы строку соответствующую текущей позиции курсора.
 *
 * За курсором должна быть текущая запись, иначе будет возвращена ошибка.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_del(fpta_cursor *cursor);

/* Конвертирует поле кортежа в более унифицированное значение. */
fpta_value_type fpta_field2value(const fptu_field *pf);

/* Обновляет или добавляет в кортеж значение колонки.
 *
 * Аргумент column_id идентифицирует колонку и должен быть
 * предварительно подготовлен посредством fpta_schema_refresh().
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_row_upsert(const fptu_rw *pt, const fpta_schema_id *column_id,
                    fpta_value_type value);

#ifdef __cplusplus
}
#endif

#endif /* FAST_POSITIVE_TABLES_H */
