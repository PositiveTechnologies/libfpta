/*
 * Copyright 2016 libfpta authors: please see AUTHORS file.
 *
 * This file is part of libfpta, aka "Fast Positive Tables".
 *
 * libfpta is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * libfpta is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with libfpta.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * libfpta = { Fast Positive Tables, aka Позитивные Таблицы }
 * Please see README.md
 *
 * "Позитивные таблицы" предназначены для построения высокоскоростных
 * локальных хранилищ структурированных данных в разделяемой памяти,
 * с целевой производительностью от 100К до 1000К простых SQL-подобных
 * запросов в секунду на каждом ядре процессора.
 *
 * The Future will Positive. Всё будет хорошо.
 *
 * "Positive Tables" is designed to build high-speed local storage of
 * structured data in shared memory, with target performance from 100K
 * to 1000K simple SQL-like requests per second on each CPU core.
 */

#pragma once
#ifndef FAST_POSITIVE_TABLES_H
#define FAST_POSITIVE_TABLES_H

#include "fast_positive/defs.h"
#include "fast_positive/tuples.h"

#include <errno.h>   // for error codes
#include <string.h>  // for strlen
#include <sys/uio.h> // for struct iovec

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
/* Общие перечисления и структуры */

/* Основные ограничения, константы и их производные. */
enum fpta_bits {
    /* Максимальное кол-во таблиц */
    fpta_tables_max = 1024,
    /* Максимальное кол-во колонок (порядка 1000) */
    fpta_max_cols = fptu_max_cols,

    /* Максимальная длина ключа и/или индексируемого поля. Ограничение
     * актуально только для строк и бинарных данных переменной длины.
     *
     * При превышении заданной величины в индекс попадет только
     * помещающаяся часть ключа, с дополнением 64-битным хэшем остатка.
     *
     * Для эффективного индексирования значений, у которых наиболее значимая
     * часть находится в конце (например доменных имен), предусмотрен
     * специальный тип реверсивных индексов. При этом ограничение сохраняется,
     * но ключи обрабатываются и сравниваются с конца.
     *
     * Ограничение можно немного "подвинуть" за счет производительности,
     * но нельзя убрать полностью. Также будет рассмотрен вариант перехода
     * на 128-битный хэш. */
    fpta_max_keylen = 64 * 1 - 8,

    /* Минимальная длина имени/идентификатора */
    fpta_name_len_min = 1,
    /* Максимальная длина имени/идентификатора */
    fpta_name_len_max = 42,

    /* Далее внутренние технические делали. */
    fpta_schema_id_bits = 64,

    fpta_column_typeid_bits = fptu_typeid_bits,
    fpta_column_typeid_shift = 0,
    fpta_column_typeid_mask = (1 << fptu_typeid_bits) - 1,

    fpta_column_index_bits = 4,
    fpta_column_index_shift = fpta_column_typeid_bits,
    fpta_column_index_mask = ((1 << fpta_column_index_bits) - 1)
                             << fpta_column_index_shift,

    fpta_column_flag_bits = 4,
    fpta_name_hash_bits = fpta_schema_id_bits - fpta_column_typeid_bits -
                          fpta_column_index_bits,
    fpta_name_hash_shift = fpta_column_index_shift + fpta_column_index_bits
};

/* Экземпляр базы.
 *
 * Базу следует открыть посредством fpta_db_open(), а по завершении всех
 * манипуляций закрыть через fpta_db_close().
 * Открытие и закрытие базы относительно дорогие операции. */
typedef struct fpta_db fpta_db;

/* Транзакция в базе.
 *
 * Чтение и изменение данных всегда происходят в контексте транзакции.
 * Транзакции инициируются посредством fpta_transaction_begin()
 * и завершается через fpta_transaction_end(). */
typedef struct fpta_txn fpta_txn;

/* Курсор для чтения и изменения данных.
 *
 * Курсор связан с диапазоном записей, которые выбираются по
 * задаваемому индексу и опционально фильтруются (если задан фильтр).
 * Курсор позволяет "ходить" по записям, обновлять их и удалять.
 * Открывается курсов посредством fpta_cursor_open(), а закрывается
 * соответственно через fpta_cursor_close(). */
typedef struct fpta_cursor fpta_cursor;

//----------------------------------------------------------------------------

/* Представление времени.
 *
 * В формате фиксированной точки 32-dot-32:
 *   - В старшей "целой" части секунды по UTC, буквально как выдает time(),
 *     но без знака. Это отодвигает проблему 2038-го года на 2106,
 *     требуя взамен аккуратности при вычитании.
 *   - В младшей "дробной" части неполные секунды в 1/2**32 долях.
 *
 * Эта форма унифицирована с Positive Hyper100r и одновременно достаточно
 * удобна в использовании. Поэтому настоятельно рекомендуется использовать
 * именно её, особенно для хранения и передачи данных. */
typedef union fpta_time {
    uint64_t fixedpoint;
    struct {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        uint32_t fractional;
        uint32_t utc;
#else
        uint32_t utc;
        uint32_t fractional;
#endif
    };
} fpta_time;

/* Возвращает текущее время в правильной форме. */
fpta_time fpta_now();

/* Типы данных для ключей (проиндексированных полей) и значений
 * для сравнения в условиях фильтров больше/меньше/равно/не-равно. */
typedef enum fpta_value_type {
    fpta_null,       /* "Пусто", в том числе для проверки присутствия
                      * или отсутствия колонки/поля в строке. */
    fpta_signed_int, /* Integer со знаком, задается в int64_t */
    fpta_unsigned_int, /* Беззнаковый integer, задается в uint64_t */
    fpta_datetime, /* Время в форме fpta_time */
    fpta_float_point, /* Плавающая точка, задается в double */
    fpta_string, /* Строка, задается в const char* */
    fpta_binary, /* Бинарные данные, задается адресом и длинной */
    fpta_shoved, /* Преобразованный длинный ключ из индекса. */
    fpta_begin,  /* Псевдо-тип, всегда меньше любого значения.
                  * Используется при открытии курсора для выборки
                  * первой записи посредством range_from. */
    fpta_end,    /* Псевдо-тип, всегда больше любого значения.
                  * Используется при открытии курсора для выборки
                  * последней записи посредством range_to. */
} fpta_value_type;

/* Структура для представления значений.
 *
 * В том числе для передачи ключей (проиндексированных полей)
 * и значений для сравнения в условия больше/меньше/равно/не-равно. */
typedef struct fpta_value {
    fpta_value_type type;
    unsigned binary_length;
    union {
        int64_t sint;
        uint64_t uint;
        double fp;
        const char *cstr;
        void *binary_data;
    };
#ifdef __cplusplus
// TODO: constructors from basic types.
#endif
} fpta_value;

/* Конструктор value с целочисленным значением. */
static __inline fpta_value fpta_value_sint(int64_t value)
{
    fpta_value r;
    r.type = fpta_signed_int;
    r.sint = value;
    return r;
}

/* Конструктор value с беззнаковым целочисленным значением. */
static __inline fpta_value fpta_value_uint(uint64_t value)
{
    fpta_value r;
    r.type = fpta_unsigned_int;
    r.uint = value;
    return r;
}

/* Конструктор value с плавающей точкой. */
static __inline fpta_value fpta_value_float(double value)
{
    fpta_value r;
    r.type = fpta_float_point;
    r.fp = value;
    return r;
}

/* Конструктор value со строковым значением,
 * строка не копируется и не хранится внутри. */
static __inline fpta_value fpta_value_str(const char *value)
{
    fpta_value r;
    r.type = fpta_string;
    r.cstr = value;
    r.binary_length = value ? strlen(value) : 0;
    return r;
}

/* Конструктор value с void/null значением. */
static __inline fpta_value fpta_value_null()
{
    fpta_value r;
    r.type = fpta_null;
    return r;
}

/* Конструктор value с псевдо-значением "начало". */
static __inline fpta_value fpta_value_begin(void)
{
    fpta_value r;
    r.type = fpta_begin;
    return r;
}

/* Конструктор value с псевдо-значением "конец". */
static __inline fpta_value fpta_value_end(void)
{
    fpta_value r;
    r.type = fpta_end;
    return r;
}

//----------------------------------------------------------------------------

/* Коды ошибок.
 * Список будет пополнен, а описания уточнены. */
enum fpta_error {
    FPTA_SUCCESS = 0,
    FPTA_OK = FPTA_SUCCESS,
    FPTA_ERRROR_BASE = 4242,

    FPTA_EOOPS /* Internal unexpected Oops */,
    FPTA_SCHEMA_CORRUPTED /* */,
    FPTA_ETYPE /* Type mismatch */,
    FPTA_DATALEN_MISMATCH,
    FPTA_ROW_MISMATCH /* Row schema is mismatch */,
    FPTA_INDEX_CORRUPTED,
    FPTA_ETXNOUT /* Transaction should be restared */,
    FPTA_ECURSOR /* Cursor not positioned */,

    FPTA_EINVAL = EINVAL,
    FPTA_ENOFIELD = ENOENT,
    FPTA_ENOMEM = ENOMEM,
    FPTA_EVALUE = EDOM /* Numeric value out of range*/,
    FPTA_NODATA = -1 /* EOF */,
    FPTA_ENOIMP = ENOSYS,

    FPTA_DEADBEEF = 0xDeadBeef
};

/* Возвращает краткое описание ошибки по её коду.
 *
 * Функция идентифицирует "свои" ошибки и при необходимости по-цепочке
 * вызывает mdbx_strerror() и системную strerror().
 *
 * Функция потоко-НЕ-безопасна в случае системной ошибки, так как при
 * этом вызывается потоко-НЕ-безопасная системная strerror(). */
const char *fpta_strerror(int error);

/* Потоко-безопасный вариант fpta_strerror().
 *
 * Функция потоко-безопасна в том числе в случае системной ошибки, так
 * как при этом вызывается потоко-безопасная системная strerror_r(). */
int fpta_strerror_r(int errnum, char *buf, size_t buflen);

//----------------------------------------------------------------------------
/* Открытие и закрытие БД */

/* Режим сохранности для изменений и БД в целом.
 *
 * Одновременно выбирает компромисс между производительностью по записи
 * и durability. */
typedef enum fpta_durability {

    fpta_readonly, /* Только чтение, изменения запрещены. */

    fpta_sync, /* Полностью синхронная запись на диск.
                * Самый надежный и самый медленный режим.
                *
                * По завершению транзакции выполняется fdatasync().
                * Производительность по записи определяется
                * скоростью диска (порядка 500 TPS для SSD). */

    fpta_lazy, /* "Ленивый" режим записи посредством файловой
                * системы. Детали поведения и сохранность данных
                * полностью определяются видом файловой системой
                * и её настройками. Производительность по записи
                * в основном определяется скоростью диска (порядка
                * 50K TPS для SSD).
                *
                * Изменения будут записываться через файловый
                * дескриптор в обычном режиме, без O_SYNC, O_DSYNC
                * и/или O_DIRECT.
                * В случае аварии могут быть потеряны последние
                * транзакции, при это целостность БД определяется
                * соблюдением data ordered со стороны ФС.
                *
                * Другими словами, кроме потери последних изменений
                * БД может быть разрушена, если ФС переупорядочивает
                * порядок операций записи (см режим data=writeback
                * для ext4). */

    fpta_async /* Самый быстрый режим. Образ БД отображается в
                * память в режиме read-write и изменения
                * производятся только в памяти.
                *
                * Ядро ОС, по своему усмотрению, асинхронно
                * записывает измененные страницы на диск.
                * При этом ядро ОС обещает запись всех изменений
                * при сбое приложения, OOM или при штатной
                * остановке. Но НЕ при сбое в ядре или при
                * отключении питания.
                *
                * Также, БД может быть повреждена в результате
                * некорректных действий приложения (роспись памяти).
                *
                * Производительность по записи в основном
                * определяется скоростью CPU и RAM (более 100K TPS). */
} fpta_durability;

/* Открывает базу по заданному пути и в durability режиме.
 *
 * Аргумент file_mode задает права доступа, которые используются
 * в случае создания новой БД.
 *
 * Аргумент megabytes задает размер БД в мегабайтах. При создании новой
 * БД за основным файлом БД резервируется указанное место. При открытии
 * существующей БД, в зависимости от заданного размера, может быть
 * приведено как увеличения файла, так и его усечение. Причем усечение
 * выполняется не более чем до последней использованной страницы.
 *
 * Аргумент alterable_schema определяет намерения по созданию и/или
 * удалению таблиц в процессе работы. Обещание "не менять схему"
 * позволяет отказаться от захвата pthread_rwlock_t в процессе работы.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_db_open(const char *path, fpta_durability durability,
                 mode_t file_mode, size_t megabytes, bool alterable_schema,
                 fpta_db **db);

/* Закрывает ранее открытую базу.
 *
 * На момент закрытия базы должны быть закрыты все ранее открытые
 * курсоры и завершены все транзакции.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_db_close(fpta_db **db);

//----------------------------------------------------------------------------
/* Инициация и завершение транзакций. */

/* Уровень доступа к данным из транзакции. */
typedef enum fpta_level {

    fpta_read = 1, /* Только чтение.
                    * Одновременно бесконфликтно могут выполняться
                    * несколько транзакций в режиме чтения. При
                    * этом они не блокируются пишущими транзакциями,
                    * как из этого же процесса, так и из других
                    * процессов работающих с БД.
                    *
                    * Однако, транзакция уровня изменения схемы
                    * всегда блокирует читающие транзакции в рамках
                    * того же процесса (но не в других процессах).
                    *
                    * При старте каждая читающая транзакция получает
                    * в свое распоряжение консистентный MVCC снимок
                    * всей БД, который видит до своего завершения.
                    * Другими словами, читающая транзакция не видит
                    * изменений в данных, которые произошли после
                    * её старта.
                    *
                    * По этой же причине следует избегать долгих
                    * читающих транзакций. Так как такая долгая
                    * транзакция производит удержание снимка-версии
                    * БД в линейной истории и этим приостанавливает
                    * переработку старых снимков (сборку мусора).
                    * Соответственно, долгая читающая транзакция
                    * на фоне большого темпа изменений может
                    * приводить к исчерпанию свободного места в БД. */

    fpta_write = 2, /* Чтение и изменение данных, но не схемы.
                     *
                     * Одновременно в одной БД может быть активна только
                     * одна транзакция изменяющая данные. Проще говоря,
                     * при старте такой транзакции захватывается
                     * глобальный мьютех в разделяемой памяти.
                     *
                     * Пишущая транзакция никак не мешает выполнению
                     * читающих транзакций как в этом, так и в других
                     * процессах.
                     *
                     * Изменения сделанные из пишущей транзакции сразу
                     * видны в её контексте. Но для других транзакций и
                     * процессов они вступят в силу и будут видимы
                     * только после успешной фиксации транзакции.
                     *
                     * Пишущая транзакция может быть либо зафиксирована,
                     * либо отменена (при этом теряются все произведенные
                     * изменения). */

    fpta_schema = 3 /* Чтение, плюс изменение данных и схемы.
                     *
                     * Прежде всего, это пишущая транзакция, т.е.
                     * в пределах БД может быть активна только одна.
                     * Аналогично, транзакция изменения схемы может быть
                     * либо зафиксирована, либо отменена (с потерей всех
                     * изменений).
                     *
                     * Однако, транзакция изменения схемы также
                     * блокирует все читающие транзакции в рамках
                     * своего процесса посредством pthread_rwlock_t.
                     * Такая блокировка обусловлена двумя причинами:
                     *  - спецификой движков libmdbx/LMDB (удаление
                     *    таблицы приводит к закрытию её разделяемого
                     *    дескриптора, т.е. к нарушению MVCC);
                     *  - ради упрощения реализации "Позитивных Таблиц";
                     *
                     * Инициация транзакции изменяющей схему возможна,
                     * только если при БД была открыта в соответствующем
                     * режиме (было задано alterable_schema = true).
                     *
                     * С другой стороны, обещание не менять схему
                     * (указание alterable_schema = false) позволяет
                     * экономить на захвате pthread_rwlock_t при старте
                     * читающих транзакций. */
} fpta_level;

/* Инициация транзакции заданного уровня.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_transaction_begin(fpta_db *db, fpta_level level, fpta_txn **txn);

/* Завершение транзакции.
 *
 * Аргумент abort для пишущих транзакций (уровней fpta_write и fpta_schema)
 * определяет будет ли транзакция зафиксирована или отменена.
 *
 * На момент завершения транзакции должны быть закрыты все связанные
 * с ней курсоры.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_transaction_end(fpta_txn *txn, bool abort);

/* Получение версии данных и схемы.
 *
 * Для снимка данных (которая читается транзакцией)
 * и версию схемы (которая действует внутри транзакции).
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_transaction_versions(fpta_txn *txn, size_t *data, size_t *schema);

//----------------------------------------------------------------------------
/* Управление схемой:
 *  - Изменение схемы происходит в рамках "пишущей" транзакции
 *    уровня fpta_schema.
 *  - Можем создавать таблицы, указывая имя и "набор колонок".
 *  - Можем удалять таблицы по имени.
 *  - Изменения вступают в силу и видны другим процессам только
 *    после фиксации транзакции.
 *
 *  - "Набор колонок" задается в виде массива, каждый элемент которого
 *    создается отдельной вспомогательной функцией.
 *  - При описании колонки указывается её имя, тип данных и признак
 *    индексируемости (primary, secondary, none).
 *  - Для каждой таблицы ровно одна колонка должна быть помечена
 *    как primary.
 *
 * Хэш-коллизии в именах:
 *  - Имена таблиц и колонок подвергаются компактификации (сжатию).
 *  - Можно сказать, что из исходного имени формируется 55-битное
 *    хэш-значение. Соответственно, с вероятностью примерно
 *    1 к 190 миллионам возможна хэш-коллизия.
 *  - При возникновении такой коллизии, при создании таблицы будет
 *    возвращаться ошибка. Как если бы такая таблица уже существовала,
 *    или среди её колонок есть дубликат.
 */

/* Режимы индексирования для колонок таблиц.
 *
 * Вторичные индексы возможны только при уникальности ключей в первичном
 * индексе. При невозможности обеспечить уникальность по какому-либо полю
 * следует добавить еще одну колонку, заполняя её при вставке текущим
 * временем получаемым от fpta_now().
 *
 * Неупорядоченные индексы:
 *   - fpta_primary_unique_unordered, fpta_primary_withdups_unordered;
 *   - fpta_secondary_unique_unordered, fpta_secondary_withdups_unordered.
 *
 *   Строятся посредством хеширования значений ключа. Такой bндекс позволяет
 *   искать данные только по конкретному значению ключа. Основной бонус при
 *   этом в минимизации накладных расходов, так как внутри БД все ключи
 *   становятся одинакового фиксированного размера.
 *
 * Индексы со сравнением ключей с конца:
 *   - fpta_primary_unique_reversed, fpta_primary_withdups_reversed;
 *   - fpta_secondary_unique_reversed, fpta_secondary_withdups_reversed.
 *
 *   Индексы этого типа применимы только для строк и бинарных данных (типы
 *   fptu_96..fptu_256, fptu_string и fptu_opaque При этом значения ключей
 *   сравниваются в обратном порядке байт. Не от первых к последним,
 *   а от последних к первым. Не следует пусть с обратным порядком сортировки
 *   или упорядочения величин.
 */
enum fpta_index_type {
    /* служебные флажки/битики для комбинаций */
    fpta_index_funique = 1 << fpta_column_index_shift,
    fpta_index_fordered = 2 << fpta_column_index_shift,
    fpta_index_fobverse = 4 << fpta_column_index_shift,
    fpta_index_fsecondary = 8 << fpta_column_index_shift,

    /* Колонка НЕ индексируется и в последствии не может быть указана
     * при открытии курсора как опорная. */
    fpta_index_none = 0,

    /* Первичный ключ/индекс.
     *
     * Колонка будет использована как первичный ключ таблицы. При создании
     * таблицы такая колонка должна быть задана одна, и только одна. Вторичные
     * ключи/индексы допустимы только при уникальности по первичному ключу. */

    /* с повторами */
    fpta_primary_withdups = fpta_index_fordered + fpta_index_fobverse,

    /* с контролем уникальности */
    fpta_primary_unique = fpta_primary_withdups + fpta_index_funique,

    /* неупорядоченный, с контролем уникальности */
    fpta_primary_unique_unordered = fpta_primary_unique - fpta_index_fordered,

    /* неупорядоченный с повторами */
    fpta_primary_withdups_unordered =
        fpta_primary_withdups - fpta_index_fordered,

    /* строки и binary сравниваются с конца, с контролем уникальности */
    fpta_primary_unique_reversed = fpta_primary_unique - fpta_index_fobverse,

    /* строки и binary сравниваются с конца, с повторами */
    fpta_primary_withdups_reversed =
        fpta_primary_withdups - fpta_index_fobverse,

    /* базовый вариант для основного индекса */
    fpta_primary = fpta_primary_unique,

    /* Вторичный ключ/индекс.
     *
     * Для колонки будет поддерживаться вторичный индекс, т.е. будет создана
     * дополнительная служебная таблица с key-value проекцией на первичный
     * ключ. Поэтому каждый вторичный индекс линейно увеличивает стоимость
     * операций обновления данных. Вторичные ключи/индексы допустимы только
     * при уникальности по первичному ключу. */

    /* с повторами */
    fpta_secondary_withdups = fpta_primary_withdups + fpta_index_fsecondary,

    /* с контролем уникальности */
    fpta_secondary_unique = fpta_secondary_withdups + fpta_index_funique,

    /* неупорядоченный, с контролем уникальности */
    fpta_secondary_unique_unordered =
        fpta_secondary_unique - fpta_index_fordered,

    /* неупорядоченный с повторами */
    fpta_secondary_withdups_unordered =
        fpta_secondary_withdups - fpta_index_fordered,

    /* строки и binary сравниваются с конца, с контролем уникальности */
    fpta_secondary_unique_reversed =
        fpta_secondary_unique - fpta_index_fobverse,

    /* строки и binary сравниваются с конца, с повторами */
    fpta_secondary_withdups_reversed =
        fpta_secondary_withdups - fpta_index_fobverse,

    /* базовый вариант для вторичных индексов */
    fpta_secondary = fpta_secondary_withdups,
};

/* Набор колонок для создания таблицы */
typedef struct fpta_column_set {
    /* Счетчик заполненных описателей. */
    unsigned count;
    /* Упакованное внутреннее описание колонок. */
    uint64_t internal[fpta_max_cols];
} fpta_column_set;

/* Вспомогательная функция, проверяет корректность имени */
bool fpta_name_validate(const char *name);

/* Вспомогательная функция для создания описания колонок.
 *
 * Добавляет описание колонки в column_set.
 * Аргумент column_name задает имя колонки. Для совместимости в именах
 * таблиц и колонок допускаются символы: 0-9 A-Z a-z _
 * Начинаться имя должно с буквы. Регистр символов не различается.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_column_describe(const char *column_name, enum fptu_type data_type,
                         fpta_index_type index_type,
                         fpta_column_set *column_set);

/* Инициализирует column_set перед заполнением посредством
 * fpta_column_describe(). */
void fpta_column_set_init(fpta_column_set *column_set);

/* Создание таблицы.
 *
 * Аргумент table_name задает имя таблицы. Для совместимости в именах
 * таблиц и колонок допускаются символы: 0-9 A-Z a-z _
 * Начинаться имя должно с буквы.
 *
 * Аргумент column_set должен быть предварительно заполнен
 * посредством fpta_column_describe(). После создания таблицы column_set
 * не требуется и может быть разрушен.
 *
 * Требуется транзакция уровня fpta_schema. Изменения становятся
 * видимыми из других транзакций и процессов только после успешной
 * фиксации транзакции.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_table_create(fpta_txn *txn, const char *table_name,
                      fpta_column_set *column_set);

/* Удаление таблицы.
 *
 * Требуется транзакция уровня fpta_schema. Изменения становятся
 * видимыми из других транзакций и процессов только после успешной
 * фиксации транзакции.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_table_drop(fpta_txn *txn, const char *table_name);

//----------------------------------------------------------------------------
/* Отслеживание версий схемы,
 * Идентификаторы таблиц/колонок и их кэширование:
 *
 *  - Следует учитывать что схема и все данные могут быть полностью
 *    изменены сторонним процессом. Такое изменение всегда происходит
 *    в контексте "пишущей" транзакции, т.е. изолированно от уже
 *    выполняющихся транзакций чтения.
 *    Другими словами, следует считать, что вне контекста транзакции,
 *    схема и данные волатильны и обновляются асинхронно.
 *
 *  - Таким образом, по-хорошему, трансляция имен таблиц и колонок в
 *    их идентификаторы и фактические типы данных, должна выполняться
 *    в контексте транзакции, т.е. после её инициации.
 *    Однако, изменение схемы происходит редко и не рационально
 *    выполнять такую трансляцию при каждом запросе.
 *    Более того, такая трансляция не может быть эффективно реализована
 *    для всех сценариев получения и обновления данных без введения
 *    некого языка запросов и его интерпретатора.
 *
 *  - Поэтому часть задач по отслеживанию версий схемы и трансляции
 *    имен в идентификаторы переложена на пользователя, см далее.
 *
 *  - При выполнении запросов идентификация таблиц и колонок
 *    производится посредством полей структуры fpta_schema_id.
 *
 *    В свою очередь, каждый экземпляр fpta_schema_id:
 *     1) инициализируется посредством fpta_schema_init(),
 *        которая на вход получает имя таблицы или колонки.
 *     2) перед использованием обновляется в fpta_schema_refresh(),
 *        которая выполняется в контексте конкретной транзакции.
 *
 *  - Функция fpta_schema_refresh(), при обновлении fpta_schema_id,
 *    сравнивает версию схемы в текущей транзакции со значением
 *    внутри fpta_schema_id, и при их совпадении не производит
 *    каких-либо действий.
 *
 *  - Таким образом, пользователю предоставляются средства для
 *    эффективного кэширования зависящей от схемы информации,
 *    а также её обновления по необходимости.
 */

/* Операционный идентификатор таблицы или колонки. */
typedef struct fpta_schema_id {
    size_t version; /* версия схемы для кэширования. */
    uint64_t internal; /* хэш имени и внутренние данные. */
    union {
        /* для таблицы */
        struct {
            unsigned dbi;
            unsigned pk;
        } table;

        /* для колонки */
        struct {
            int order;           /* номер поля в кортеже. */
            enum fptu_type type; /* тип поля в кортеже. */
        } column;
    };
    void *handle; /* внутренний дескриптор. */
} fpta_schema_id;

/* Получение и актуализация идентификаторов таблицы и колонки.
 *
 * Функция работает в семантике кэширования с отслеживанием версии
 * схемы.
 *
 * Перед первым обращением table_id и column_id должны
 * быть инициализирован посредством fpta_schema_init().
 *
 * Аргумент column_id может быть нулевым. В этом случае он
 * игнорируется, и обрабатывается только table_id.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_schema_refresh(fpta_txn *txn, fpta_schema_id *table_id,
                        fpta_schema_id *column_id);

enum fpta_schema_item { fpta_table, fpta_column };

/* Инициализирует операционный идентификатор.
 *
 * Подготавливает идентификатор к последующему использованию.
 * Аргумент schema_item определяет тип объекта, который будет
 * идентифицироваться.
 *
 * Следует считать, что стоимость операции сопоставима с вычислением
 * дайджеста MD5 для переданного имени.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_schema_init(fpta_schema_id *id, const char *name,
                     enum fpta_schema_item schema_item);
void fpta_schema_destroy(fpta_schema_id *id);

//----------------------------------------------------------------------------
/* Управление фильтрами. */

/* Варианты условий (типы узлов) фильтра: НЕ, ИЛИ, И, функция-предикат,
 * меньше, больше, равно, не равно... */
typedef enum fpta_filter_bits {
    fpta_node_not = -3,
    fpta_node_or = -2,
    fpta_node_and = -1,
    fpta_node_fn = 0,
    fpta_node_lt = fptu_lt,
    fpta_node_gt = fptu_gt,
    fpta_node_le = fptu_le,
    fpta_node_ge = fptu_ge,
    fpta_node_eq = fptu_eq,
    fpta_node_ne = fptu_ne,
} fpta_filter_bits;

/* Фильтр, формируется пользователем как дерево из узлов-условий.
 *
 * Фильтр может быть пустым, состоять из одного узла или целого дерева
 * начиная с коревого узла типа И или ИЛИ.
 *
 * Текущую реализацию можно считать базовым вариантом для быстрого старта,
 * который в последствии может быть доработан. */
typedef struct fpta_filter {
    fpta_filter_bits type;

    union {
        /* вложенный узел фильтра для "НЕ". */
        struct fpta_filter *node_not;

        /* вложенная пара узлов фильтра для условий "И" и "ИЛИ". */
        struct {
            struct fpta_filter *a;
            struct fpta_filter *b;
        } node_or, node_and;

        /* параметры для вызова функтора/предиката. */
        struct {
            /* идентификатор колонки */
            const fpta_schema_id *column_id;
            /* функция-предикат, получает указатель на найденное поле,
             * или nullptr если такового нет. А также опциональные
             * параметры context и arg.
             * Функция должна вернуть true, если значение колонки/поля
             * удовлетворяет критерию фильтрации.
             */
            bool (*predicate)(const fptu_field *field,
                              const fpta_schema_id *column_id, void *context,
                              void *arg);
            /* дополнительные аргументы для функции-предиката */
            void *context;
            void *arg;
        } node_fn;

        /* параметры для условия больше/меньше/равно/не-равно. */
        struct {
            /* идентификатор колонки */
            const fpta_schema_id *left_id;
            /* значение для сравнения */
            fpta_value right_value;
        } node_cmp;
    };
} fpta_filter;

/* Проверка соответствия кортежа условию фильтра.
 *
 * Предполагается внутреннее использование, но функция также
 * доступна извне. */
bool fpta_filter_match(fpta_filter *fn, fptu_ro tuple);

//----------------------------------------------------------------------------
/* Управление курсорами. */

/* Порядок по индексной колонке для строк видимых через курсор. */
typedef enum fpta_cursor_options {
    /* Без обязательного порядка. Требуется для неупорядоченных индексов,
     * для упорядоченных равносилен fpta_ascending */
    fpta_unordered = 0,

    /* По-возрастанию */
    fpta_ascending = 1,

    /* По-убыванию */
    fpta_descending = 2,

    /* Дополнительный флаг, предотвращающий чтение и поиск/фильтрацию
     * данных при открытии курсора. Позволяет избежать лишних операций,
     * если известно, что сразу после открытия курсор будет перемещен. */
    fpta_dont_fetch = 4
} fpta_cursor_options;

/* Создает и открывает курсор для доступа к строкам таблицы,
 * включая их модификацию и удаление. Открытый курсор должен быть
 * закрыт до завершения транзакции посредством fpta_cursor_close().
 *
 * Аргументы table_id и column_id перед первым использованием должны
 * быть инициализированы посредством fpta_schema_init(). Предварительный
 * вызов fpta_schema_refresh() не обязателен.
 *
 * Аргументы range_from и range_to задают диапазон выборки по значению
 * ключевой колонки. При необходимости могут быть заданы значения
 * с псевдо-типами fpta_begin и fpta_end.
 *
 * Для успешного открытия курсора соответствующая таблица должна быть
 * предварительно создана, а указанная колонка должна иметь индекс.
 *
 * Если курсор открывается без флага fpta_dont_fetch, то при открытии будет
 * произведено позиционирование с поиском и фильтрацией данных. При этом,
 * в случает отсутствия данных удовлетворяющих критерию выборки, будет
 * возвращена ошибка.
 *
 * Фильтр, использованный при открытии курсора, должен существовать и
 * не изменяться до закрытия курсора и всех его клонов/копий.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_open(fpta_txn *txn, fpta_schema_id *table_id,
                     fpta_schema_id *column_id, fpta_value range_from,
                     fpta_value range_to, fpta_filter *filter,
                     fpta_cursor_options op, fpta_cursor **cursor);
int fpta_cursor_close(fpta_cursor *cursor);

/* Проверяет наличие за курсором данных.
 *
 * Отсутствие данных означает что нет возможности их прочитать, изменить
 * или удалить, но не исключает возможности вставки и/или добавления
 * новых данных.
 *
 * При наличии данных возвращает 0. При отсутствии данных или неустановленном
 * курсоре FPTA_NODATA (EOF). Иначе код ошибки.
 */
int fpta_cursor_eof(fpta_cursor *cursor);

/* Делает копию курсора, т.е. клонирует его.
 *
 * Получение копии курсора можно рассматривать как способ сохранить
 * и повторно использовать его текущую позицию. Копия курсора должна
 * быть закрыта то завершения транзакции.
 * Использованный при открытии курсора фильтр должен существовать и
 * не изменяться до закрытия как исходного курсора, так и всех его
 * клонов/копий.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_clone(fpta_cursor *cursor, fpta_cursor **clone);

/* Считает и возвращает количество строк за курсором.
 *
 * Производится итеративный подсчет строк посредством временной копии курсора.
 * Операция затратна, стоимость порядка O(log(M) + N), где M это общее кол-во
 * строк в таблице, а N количество строк попадающее под критерий выборки.
 *
 * Аргумент limit задает границу, при достижении которой подсчет прекращается.
 * Если limit равен 0, то поиск производится до первой подходящей строки.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_count(fpta_cursor *cursor, size_t *count, size_t limit);

/* Считает и возвращает количество дубликатов для ключа в текущей
 * позиции курсора, БЕЗ учета фильтра заданного при открытии курсора.
 *
 * За курсором должна быть текущая запись. Под дубликатами понимаются
 * запись с одинаковым значением ключевой колонки, что допустимо если
 * соответствующий индекс не требует уникальности.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_dups(fpta_cursor *cursor, size_t *dups);

/* Возвращает строку таблицы, на которой стоит курсор.
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_get(fpta_cursor *cursor, fptu_ro *tuple);

/* Варианты перемещения курсора. */
typedef enum fpta_seek_operations {
    /* Перемещение по диапазону строк за курсором. */
    fpta_first,
    fpta_last,
    fpta_next,
    fpta_prev,

    /* Перемещение по дубликатам текущего значения ключа, т.е.
     * по набору строк, у которых значение ключевого поля совпадает
     * с текущей строкой. */
    fpta_dup_first,
    fpta_dup_last,
    fpta_dup_next,
    fpta_dup_prev,

    /* Перемещение с пропуском дубликатов, т.е.
     * переход осуществляется к строке со значением ключевого поля
     * отличным от текущего. */
    fpta_key_next,
    fpta_key_prev
} fpta_seek_operations;

/* Относительное перемещение курсора.
 *
 * Курсор перемещается к соответствующей строке в пределах диапазона и
 * с учетом фильтра, заданных при открытии курсора.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_move(fpta_cursor *cursor, fpta_seek_operations op);

/* Перемещение курсора к заданному ключу и/или строке.
 *
 * Курсор перемещается к соответствующей строке в пределах диапазона и
 * с учетом фильтра, заданных при открытии курсора.
 *
 * Аргументы key или row адресуют строку, которую необходимо найти. Должен
 * быть задан (не равен nullptr) один и только один из них. Стоит обратить
 * внимание, что курсор при этом не увидит (и не найдет) строк вне диапазонна,
 * заданного при открытии курсора.
 *
 * Аргумент exactly определяет требуется ли поиск именно заданного значения,
 * либо курсор необходимо переместить к ближайшей позиции.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_locate(fpta_cursor *cursor, bool exactly,
                       const fpta_value *key, const fptu_ro *row);

/* Возвращает внутреннее значение ключа, которое соответствует
 * текущей позиции курсора.
 *
 * Функцию следует считать вспомогательно-отладочной. Возвращаемое значение
 * может не соответствовать значению в соответствующей колонки строки.
 * Так например, вместо длинной строки будет возвращено обрезанное бинарное
 * значение с хэшем в конце.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_key(fpta_cursor *cursor, fpta_value *key);

//----------------------------------------------------------------------------
/* Манипуляция данными. */

/* Опции при помещении или обновлении данных, т.е. для fpta_cursor_put(). */
typedef enum fpta_put_options {
    /* Вставить новую запись, т.е. не обновлять существующую.
     * Будет возвращена ошибка, если указанный ключ уже присутствует в
     * таблице и соответствующий индекс требует уникальности. */
    fpta_insert,
    fpta_not_overwrite = fpta_insert,

    /* Не добавлять новую запись, а обновить текущую запись.
     *
     * При обновлении посредством fpta_cursor_update() за курсором должна
     * быть текущая запись, а в новом значении строки ключевое поле должно
     * совпадать со значением в текущей позиции курсора, иначе будет
     * возвращена ошибка. */
    fpta_update,
    fpta_overwrite = fpta_update,

    /* Обновить существующую запись, либо вставить новую. Опция допустима
     * только если соответствующий индекс требует уникальности, иначе будет
     * возвращена ошибка. */
    fpta_upsert
} fpta_put_options;

/* Обновляет строку в текущей позиции курсора.
 *
 * При обновлении не допускается изменение значения ключевой колонки,
 * которая была задана посредством column_id при открытии курсора.
 *
 * В противном случае возникает ряд вопросов по состоянию и дальнейшему
 * поведению курсора, в частности:
 *  - на какую запись должен указывать курсор после такого обновления?
 *  - должен ли курсор следовать за измененным ключом?
 *    если да, то как он должен вести себя при последующих перемещениях?
 *  - должен ли курсор переходить на следующую запись?
 *    если да, то каким должно быть поведение без изменения ключевого поля?
 *    в какой момент и как сообщать об отсутствии "следующей" записи?
 *  - должен ли курсор повторно прочитать обновленную запись, если она была
 *    перемещена "вперед" в пределах текущей выборки.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_update(fpta_cursor *cursor, fptu_ro row_value);

/* Удаляет из таблицы строку соответствующую текущей позиции курсора.
 * После удаления курсор перемещается к следующей записи.
 *
 * За курсором должна быть текущая запись, иначе будет возвращена ошибка.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_cursor_delete(fpta_cursor *cursor, bool all_dups);

/* Конвертирует поле кортежа в более унифицированное значение. */
fpta_value fpta_field2value(const fptu_field *pf);

/* Обновляет или добавляет в кортеж значение колонки.
 *
 * Аргумент column_id идентифицирует колонку и должен быть
 * предварительно подготовлен посредством fpta_schema_refresh().
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_upsert_column(fptu_rw *pt, const fpta_schema_id *column_id,
                       fpta_value value);

/* Базовая функция для вставки и обновления строк таблицы.
 *
 * В зависимости от fpta_put_options выполняет вставку, либо обновление.
 * Для наглядности рекомендуется использовать функции-обертки определенные
 * ниже.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_put(fpta_txn *txn, fpta_schema_id *table_id, fptu_ro row_value,
             fpta_put_options op);

/* Обновляет существующую строку таблицы.
 *
 * Для колонок индексируемых с контролем уникальности наличие дубликатов не
 * допускается. Кроме этого, в любом случае, не допускается наличие полностью
 * идентичных строк.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
static __inline int fpta_update_row(fpta_txn *txn, fpta_schema_id *table_id,
                                    fptu_ro row_value)
{
    return fpta_put(txn, table_id, row_value, fpta_update);
}

/* Вставляет в таблицу новую строку.
 *
 * Для колонок индексируемых с контролем уникальности вставка дубликатов не
 * допускается. Кроме этого, в любом случае, не допускается вставка полностью
 * идентичных строк.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
static __inline int fpta_insert_row(fpta_txn *txn, fpta_schema_id *table_id,
                                    fptu_ro row_value)
{
    return fpta_put(txn, table_id, row_value, fpta_insert);
}

/* Обновляет существующую строку таблицы, либо вставляет новую.
 *
 * Для колонок индексируемых с контролем уникальности наличие дубликатов не
 * допускается. Кроме этого, в любом случае, не допускается наличие полностью
 * идентичных строк.
 *
 * В случае успеха возвращает ноль, иначе код ошибки. */
static __inline int fpta_upsert_row(fpta_txn *txn, fpta_schema_id *table_id,
                                    fptu_ro row_value)
{
    return fpta_put(txn, table_id, row_value, fpta_upsert);
}

/* Удаляет указанную строку таблицы.
 * В случае успеха возвращает ноль, иначе код ошибки. */
int fpta_delete(fpta_txn *txn, fpta_schema_id *table_id, fptu_ro row_value);

#ifdef __cplusplus
}
#endif

#endif /* FAST_POSITIVE_TABLES_H */
